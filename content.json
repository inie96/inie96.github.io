{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"About The Blog","text":"喜欢阅读📚 喜欢大自然🌿 喜欢挑战自己🏆 喜欢可爱美好的事物🦁 努力成为自己的小太阳ing🌞","link":"/about/index.html"},{"title":"文章标签","text":"","link":"/tags/index.html"},{"title":"About The Plan","text":"","link":"/plan/index.html"},{"title":"","text":"sup { position: relative; top: -0.4em; vertical-align: baseline; } sub { position: relative; top: 0.4em; vertical-align: baseline; } a:link {text-decoration:none;} a:visited {text-decoration:none;} @media screen and (min-device-pixel-ratio:0), (-webkit-min-device-pixel-ratio:0), (min--moz-device-pixel-ratio: 0) { .view { font-size:10em; transform:scale(0.1); -moz-transform:scale(0.1); -webkit-transform:scale(0.1); -moz-transform-origin:top left; -webkit-transform-origin:top left; } } .layer { }.ie { font-size: 1pt; } .ie body { font-size: 12em; } .stl_01 { position: absolute; white-space: nowrap; } .stl_02 { height: 70.08334em; font-size: 1em; margin: 0em; line-height: 0.0em; display: block; border-style: none; width: 49.58333em; } .stl_03 { position: relative; } .stl_04 { position: absolute; left: 0em; top: 0em; } .stl_05 { position: relative; width: 49.58333em; } .stl_06 { height: 7.008333em; } .ie .stl_06 { height: 70.08334em; } @font-face { font-family:\"MMPWKS+MicrosoftYaHei-Bold\"; src:url(\"3371fe3b-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_07 { font-size: 1.829167em; font-family: \"MMPWKS+MicrosoftYaHei-Bold\", \"Times New Roman\"; color: #44546B; } .stl_08 { line-height: 1.041992em; } .stl_09 { letter-spacing: 0.0004em; } .ie .stl_09 { letter-spacing: 0.0125px; } @font-face { font-family:\"DIKHKL+MicrosoftYaHei\"; src:url(\"1b0cfbf9-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_10 { font-size: 1em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #525252; } .stl_11 { letter-spacing: -0.0036em; } .ie .stl_11 { letter-spacing: -0.0582px; } @font-face { font-family:\"AJAHDD+MicrosoftYaHeiLight\"; src:url(\"ec0f8afa-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_12 { font-size: 0.870833em; font-family: \"AJAHDD+MicrosoftYaHeiLight\", \"Times New Roman\"; color: #525252; } .stl_13 { letter-spacing: 0em; } .ie .stl_13 { letter-spacing: 0px; } .stl_14 { letter-spacing: -0.2519em; } .ie .stl_14 { letter-spacing: -3.5103px; } .stl_15 { letter-spacing: -1.007em; } .ie .stl_15 { letter-spacing: -14.0303px; } .stl_16 { letter-spacing: -0.046em; } .ie .stl_16 { letter-spacing: -0.6408px; } .stl_17 { letter-spacing: -0.0905em; } .ie .stl_17 { letter-spacing: -1.2611px; } .stl_18 { letter-spacing: -0.1571em; } .ie .stl_18 { letter-spacing: -2.1883px; } .stl_19 { font-size: 1.079167em; font-family: \"MMPWKS+MicrosoftYaHei-Bold\", \"Times New Roman\"; color: #FFFFFF; } .stl_20 { letter-spacing: -0.0003em; } .ie .stl_20 { letter-spacing: -0.0054px; } .stl_21 { font-size: 1em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #585858; } .stl_22 { letter-spacing: 0.0005em; } .ie .stl_22 { letter-spacing: 0.0083px; } .stl_23 { font-size: 0.870833em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #585858; } .stl_24 { letter-spacing: -0.0004em; } .ie .stl_24 { letter-spacing: -0.0062px; } .stl_25 { letter-spacing: 0.0018em; } .ie .stl_25 { letter-spacing: 0.0255px; } .stl_26 { letter-spacing: 0.001em; } .ie .stl_26 { letter-spacing: 0.014px; } .stl_27 { letter-spacing: 0.0047em; } .ie .stl_27 { letter-spacing: 0.0662px; } .stl_28 { letter-spacing: 0.0029em; } .ie .stl_28 { letter-spacing: 0.041px; } .stl_29 { letter-spacing: 0.0036em; } .ie .stl_29 { letter-spacing: 0.0504px; } .stl_30 { letter-spacing: -0.0008em; } .ie .stl_30 { letter-spacing: -0.0115px; } .stl_31 { letter-spacing: 0.0011em; } .ie .stl_31 { letter-spacing: 0.0147px; } .stl_32 { letter-spacing: -0.0075em; } .ie .stl_32 { letter-spacing: -0.1049px; } .stl_33 { letter-spacing: 0.0022em; } .ie .stl_33 { letter-spacing: 0.0307px; } .stl_34 { letter-spacing: -0.0051em; } .ie .stl_34 { letter-spacing: -0.0705px; } .stl_35 { letter-spacing: 0.0044em; } .ie .stl_35 { letter-spacing: 0.0609px; } .stl_36 { font-size: 0.870833em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #595959; } .stl_37 { letter-spacing: 0.0038em; } .ie .stl_37 { letter-spacing: 0.0524px; }","link":"/resume/style.css"}],"posts":[{"title":"2023.3.23日记","text":"详见下文 今天有几项事件需要记录 和🐑下午休息时间漫步在”花海” IDMS新管理端产品库管理整车这部分终于做完了fianlly 得知我要和邵姐轮岗，要去新的项目组，在L那里我表现的很淡然，听他说完这个消息就径直离开了回来也没见到邵姐，估计她的内心也五味杂陈，我试着平复心情接受这shocked事情紧接着yq跟我也谈起相同的话题 我也不假思索的都和她说了 她说好吓人 也觉得不可思议熟悉的人 熟悉的工作环境 熟悉的工作 就要离开了 云愁海思令人嗟下班后我告诉🐑 他给我得形容是sad 我也绷不住了以后可能再也没有机会和🐑和大家坐在一起办公了珍惜吧 珍惜~失去才知道 得到问界礼包~手机支架立马就用上了大帆布包很有日系的感觉水杯304、316不锈钢质量也在线 要换新的工作环境了 也要搬家了~下次出一个搬家攻略","link":"/2023/03/23/2023-3-23%E6%97%A5%E8%AE%B0/"},{"title":"Vue官方视频解读","text":"详见下文 Vue核心概念渐进式js框架由浅入深 由简单到复杂 优点12345678910体积小运行效率快虚拟DOM 一种预先通过js计算 把最终的DOM操作计算出来并优化的技术由于这个DOM的操作是预处理 并没有真实的操作DOM 所以叫虚拟DOM双向数据绑定生态丰富 新手友好 展示数据步骤 12345引入Vue库创建Vue实例通过应用ID嵌入到我们的根元素（el）中将数据放入一个叫data的对象中用双括号表达式展示数据 魔力：数据变更时Vue自动更新htmlVue是响应式的reactive数据改变时 Vue会帮你更新所有页面上用到它的地方除了字符串，其他数据类型也是如此 v-for指令展示列表从实际API获取信息fetch computed计算属性reduce求和 chrome的Vue插件查看页面中的数量 v-model指令input框增加v-model指令和数量做绑定快速变更数据 初始化Vue工程12345678Vue init webpack my-projectbuildconfignode_modulessrcstatictest Vue单文件组件12345.VueHTMLJSCSS/SCSS","link":"/2023/03/24/VUE%E5%AE%98%E6%96%B9%E8%A7%86%E9%A2%91%E8%A7%A3%E8%AF%BB/"},{"title":"Vuex笔记","text":"详见下文 vuex就相当于前端的数据库，只不过是存储在内存中的 官方描述：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 基本使用 安装 npm install vuex --save main.js引入vuex12import Vuex from 'vuex'Vue.use(Vuex) 以保存登录用户名的实例讲解 store/index.js文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 公共对象，存储所有组件用到的状态const state = { user:{ name:'' }}// 唯一取值方法，计算属性const getters = { getUser(state){ //把上面的传入进来 return state.user //返回状态中的对象值 }}// 唯一可以修改state值的方法,同步阻塞// 用commit调mutations中的方法const mutations={ updateUser(state,user){ state.user = user // 把获取到的外部参数存储到状态中 }}// 异步调用mutations方法// 用dispatch调action中的方法const actions={ asyncUpdateUser(context,user){//context是上下文，就是当前这个文件的对象 context.commit('updateUser',user) }}// 暴露出去export default new Vuex.Store({ state, getters, mutations, actions,}) 在main.js中引入刚刚定义好的 1import store from './store' 在main.js中导出store 123456new Vue({ el:'#app', router, store, render:h=&gt;h(App)}) 在登录页存储 user.name 1this.$store.dispath('asyncUpdateUser',{name:this.form.name}) 在展示页获取 user.name 1this.$store.getters.getUser.name 解决浏览器刷新后Vuex数据消失问题 思路 存：监听页面是否刷新刷新了 把state对象存到ls 取：打开一个页面 判断ls中是否有state如果有 表示页面刷新过 获取ls中的state如果没有 表示第一次进入页面 取vuex中定义的state初始值 实现 修改App.vue文件 12345678mounted(){ window.addEventListener('upload',this.saveState)}methods:{ saveState(){ Vue.ls.set('state',JSON.stringify(this.$store.state)) }} 修改store/index.js文件 1234567const state = null != Vue.ls.get('state') ? JSON.parse(Vue.ls.get('state')) : { user:{ name:'' } } Vuex模块化 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： 12345678910111213141516171819202122const moduleA = { state: () =&gt; ({ ... }), mutations: { ... }, actions: { ... }, getters: { ... }}const moduleB = { state: () =&gt; ({ ... }), mutations: { ... }, actions: { ... }}const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB }})store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 以上面的用户名实例再次修改 创建store/modules/user.js文件1234567891011121314151617181920212223242526272829303132333435363738// 公共对象，存储所有组件用到的状态const user = { state: { user:{ name:'' } } // 唯一取值方法，计算属性 getters: { getUser(state){ //把上面的传入进来 return state.user //返回状态中的对象值 } } // 唯一可以修改state值的方法,同步阻塞 // 用commit调mutations中的方法 mutations: { updateUser(state,user){ state.user = user // 把获取到的外部参数存储到状态中 } } // 异步调用mutations方法 // 用dispatch调action中的方法 actions: { asyncUpdateUser(context,user){//context是上下文，就是当前这个文件的对象 context.commit('updateUser',user) } } }export default user 修改 store/index.js文件 12345678910import Vue from 'vue'import Vuex from 'vuex'import user from './modules/user' //导入模块Vue.use(Vuex)export default new Vuex.Store({ modules:{ //导出模块 user }}) 存取状态使用的是getters和actions处理，代码不用改变，但是和state相关的要变 修改App.vue 12345methods:{ saveState(){ Vue.ls.set('state',JSON.stringify(this.$store.state.user)) }}","link":"/2023/04/10/Vuex%E7%AC%94%E8%AE%B0/"},{"title":"for of的使用","text":"详见下文 for of 可以代替forEach for( let [i,v] of arr.entries)加不加中括号的区别？数组使用解构的写法去写？看你拿到的数据是什么情况的，判断是不是能够用解构的方式取到键值如果拿到的数据不行，就要转换一下arr.entries() 对象运用for of本来不能用 因为对象没有遍历器要把对象转换一下用Object.entries(obj)1234567891011121314151617var obj = {id:1,name:'abc'};for (let k in obj) {console.log(k);console.log(obj[k]);}for (let k of obj) {console.log(k);}// TypeError: es6[Symbol.iterator] is not a function解决的办法for (let [k,v] of Object.entries(obj)) {console.log(k); //获取键console.log(v); //获取值} 与其他遍历的比较for：取值不方便forEach：取值方便，但是不能添加返回，无法中途退出循环map：有返回值for in：获取值的时候还要用另一个方式，有一点麻烦1234for （let i in arr）{console.log(i); //获取键console.log(arr[v]); //获取值} for of 可以直接添加 break continue","link":"/2023/03/23/for-of%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"markdown语法","text":"10个你需要了解的md语法 1、标题 语法： 123456789# + 文字（最多到6级标题）# 标题1 ### 标题2 ##### 标题3 ####### 标题4 ######### 标题5 ########### 标题6 ####### 效果 标题1标题2标题3标题4标题5标题62、列表 无序列表 语法： 1234567891011+ a+ b+ c- d- e- f* g* h* i 效果 a b c d e f g h i 有序列表 语法： 123456789有序列表1. abc2. abc3. dada错序列表2. awfa5. awef25. dfaf 效果 有序列表 abc abc dada 错序列表 awfa awef dfaf 嵌套列表 语法： 1234567891011121314无序+ a + a1 + a2+ ba+ c有序1. a 1. adac 1. adaw 2. adfsda2. ad3. sad 效果 无序 a a1 a2 ba c 有序 a adac adaw adfsda ad sad 3、引用块 语法： 1234567引用&gt; 引用1引用1 引用1嵌套引用&gt; 嵌套引用1&gt;&gt; 嵌套引用1 效果 引用 引用1引用1 引用1 嵌套引用 嵌套引用1 嵌套引用1 4、代码块 语法： 1234567891011代码块// code`code`code多行代码块儿// ```// code// code// code// ``` 效果 代码块codecodecode 多行代码块儿 123codecodecode 5、链接 语法： 12链接[百度1](www.baidu.com) 效果 链接百度1 6、图片 语法： 1![图片](https://note.youdao.com/favicon.ico) 效果 7、分割线 语法： 12345678分割线---- - --------****** * *____ 效果 分割线 8、表格 语法： 1234567891011121314151617181920表格1|123|234|345||:-|:-:|-:||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde|表格2|123|234|345||:---|:---:|---:||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde|表格3123|234|345:-|:-:|-:abc|bcd|cdeabc|bcd|cdeabc|bcd|cde 效果 表格1|123|234|345||:-|:-:|-:||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde|表格2|123|234|345||:—|:—:|—:||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde|表格3123|234|345:-|:-:|-:abc|bcd|cdeabc|bcd|cdeabc|bcd|cde 9、复选框 语法： 12- [ ] 复选框- [x] 选中状态 效果 复选框 选中状态 10、其他 语法： 1234567891011121314151617斜体*md*粗体**md**斜体_md_斜体__md__转义\\+删除线~~删除~~ 效果 斜体md 粗体md 斜体md 粗体md 转义+ 删除线删除","link":"/2022/09/08/markdown%E8%AF%AD%E6%B3%95/"},{"title":"promise","text":"01-promise的使用1.1-promise的基本使用 promise是一种优雅的方式解决回调地狱问题 优雅在链式编程 1234567891011121314151617181920212223242526272829303132333435363738391.给Promise传入一个函数2.resolve、reject分别又是两个函数3. then传入一个函数4. catch传入一个函数new Promise((resolve,reject)=&gt;{ //函数体里面写入异步请求 //用settimeout模拟异步请求 setTimeout(()=&gt;{ resolve() },1000)}).then(()=&gt;{ console.log(1) ...//很多代码 return new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve() },2000) })}).then(()=&gt;{ console.log(2) ... return new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve() },3000) })}).then(()=&gt;{ console.log(3) ... return new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve() },4000) })}).then(()=&gt;{ console.log(4) ...}) resolve的数据就是then中res携带的结果的数据 什么时候会用promise? 一般在异步请求操作的时候，使用promise对这个异步操作进行封装，就是把异步请求扔到promise函数体里面去 promise原理 new一个promise -&gt; 构造函数（1.保存了状态信息，2.立即执行传入的函数）-&gt; 在执行传入的回调函数时，会传入2个参数，resolve,reject,这俩本身又是函数 优雅在对异步请求的代码和返回结果处理代码做了分离 优雅在对调用成功、失败结果处理做了分离 12345678new Promise((resolve,reject)=&gt;{ resolve('成功') reject('失败')}).then(res=&gt;{ console.log(res)}).catch(err=&gt;{ console.log(err)}) promise的三种状态和图解 1.2-promise的另外处理形式12345678910new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('成功') //reject('失败') },1000)}).then(res=&gt;{ console.log(res) },err=&gt;{ console.log(err) }) 1.3-promise的链式调用 promise的链式简化 需求 aaa——第一次回调结果 aaa111——第二次回调结果 aaa111222——第三次回调结果 常规写法1 1234567891011121314151617new Promise(resolve=&gt;{ setTimeout(()=&gt;{ resolve('aaa') },1000)}).then(res=&gt;{ console.log(res,'第一次处理了10行代码') return new Promise(resolve=&gt;{ resolve(res+'111') })}).then(res=&gt;{ console.log(res,'第二次处理了10行代码') return new Promise(resolve=&gt;{ resolve(res+'222') })}).then(res=&gt;{ console.log(res,'第三次处理了10行代码')}) 简化写法2 1234567891011121314151617new Promise(resolve=&gt;{ setTimeout(()=&gt;{ resolve('aaa') },1000)}).then(res=&gt;{ console.log(res,'第一次处理了10行代码') return Promise.resolve(res+'111')}).then(res=&gt;{ console.log(res,'第二次处理了10行代码') return Promise.resolve(res+'222') // return Promise.reject('error') //异常的调用 // throw 'error'}).then(res=&gt;{ console.log(res,'第三次处理了10行代码')}).catch(err=&gt;{ console.log(err)}) 简化写法3 12345678910111213new Promise(resolve=&gt;{ setTimeout(()=&gt;{ resolve('aaa') },1000)}).then(res=&gt;{ console.log(res,'第一次处理了10行代码') return res+'111'}).then(res=&gt;{ console.log(res,'第二次处理了10行代码') return res+'222'}).then(res=&gt;{ console.log(res,'第三次处理了10行代码')})","link":"/2023/05/15/promise/"},{"title":"promise和generator语法糖-async await","text":"有了 async-await、promise 还有必要学习吗? async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性。简单来说：async-await 是建立在 promise机制之上的，并不能取代其地位。 async1234async function timeout() { return 'hello world'} timeout(); //为什么没有执行'hello world' 1234async function timeout() { return 'hello world'}console.log(timeout()); //Promise {&lt;resolved&gt;: &quot;hello world&quot;} async 函数返回的是一个promise 对象，如果要获取到promise 返回值，应该用then 方法 12345678async function fn(){ return 100;}console.log(fn()); //Promise {&lt;resolved&gt;: 100}let f = fn();f.then(function(d){ console.log(d) //100}) awaitawait操作符用于等待一个Promise对象，它只能在异步函数async function内部使用。返回值：返回promise对象的处理结果，如果等待的不是promise对象，则返回该值本身如果一个promise被传递给一个await操作符，await将等待promise正常处理完成并返回其处理结果 12345678910function f2(){ console.log(4)}async function f(){ await f2(); console.log(2) }f();console.log(3);// 4 3 2 正常情况下，await命令后面是一个promise对象，它也可以是其它值，如字符串，布尔值，数值以及普通函数。 123456789console.log(2)async function fn(){ console.log(3) await 100; console.log(1)}fn()console.log(4)// 2 3 4 1 await命令后面是一个promise对象 12345678910111213function p(){ return new Promise(resolve=&gt;{ resolve(); console.log(1) });};async function fn(){ console.log(2) await p(); console.log(3)}fn()// 2 1 3","link":"/2022/08/13/promise%E5%92%8Cgenerator%E8%AF%AD%E6%B3%95%E7%B3%96-async-await/"},{"title":"Vue CLI——脚手架","text":"详见下文 什么是Vue CLI CLI是 Command Line Interface 命令行界面 俗称脚手架 主要作用就是快速搭建vue开发环境和对应的webpack配置（最重要就是生成webpack配置） 准备工作 Vue CLI 使用前提——Node Vue CLI 使用前提——Webpack Vue CLI使用 安装 Vue CLI 拉取脚手架2 Vue CLI2初始化项目 Vue CLI3初始化项目ES(js)Lint 会让es代码写的更规范e2e test 就是 end to end 端到端测试 cli2创建项目是runtimecompiler和runtimeonly的区别（面试可能问）仅在main.js中存在区别 过程解释模板通过template: 传给vue的时候，vue会做个保存，保存在vm.optionsparse——解析ast——抽象语法树（abstract syntax tree）compile——编译render函数virtual dom —— 虚拟domUI上面的是真实dom，最终会把虚拟dom渲染成真实dom 区别 runtime-compiler：template-&gt;ast-&gt;render-&gt;vdom-&gt;UIruntime-only：render-&gt;vdom-&gt;UI 下面的文件更轻，打包更小，以后项目都选runtime-only render函数是什么 render函数的用法 普通用法，给createElement函数传入元素名、属性、内容 给createElement函数传入组件 render(h)=&gt;{return h(APP)} 这个h只是个函数名代号其实是createElement这个函数 npm run dev 和 build 底层图 修改webpack配置: 起别名(参照其他讲过的) 认识 Vue CLI3 1$mount('#app') 和 el:'#app' 方式都是一样的 在源码做了一层判断，如果没有传el就会自己执行 $mount('#app')，最终都是把#app的元素替换成传入的元素 如何找到vue的配置文件 vue ui 会启动一个可视化本地服务，里面可以修改配置 去modules文件里找 添加vue.config.js文件，到时候会和vue的module里面的配置进行合并 扩展 -g 全局安装 global yarn的出现是因为早期npm不好用，想要取代它出现的，但是随着npm的升级，npm也没那么难用 全局的gitconfig里面配置了个人信息 以前js想要运行需要搞个index.html然后跑在浏览器上现在出现了node，不用浏览器就可以执行js，node是c++开发的，核心是v8引擎 chrome比火狐、ie运行代码都快是因为chrome用了v8引擎 原来：js-&gt;字节码-&gt;浏览器现在：js-&gt;二进制代码（直接机器可读语言）v8引擎可以直接把js代码翻译成二进制代码效率很高v8引擎用c++写的 node就是服务端执行js代码的底层支撑，执行一个文件直接node 文件名 rm 是remove缩写 删除删除之前打包的文件夹配置用到 安装脚手架失败，npm缓存清除的方法——把npm-cache这个文件删掉再安装 eslint如何对代码进行检测 不一定是你们公司的规范，不同规范的写法也不一样，要花一段时间去适应 选择了eslint但是不想用怎么关掉把这个设置成false，重新编译项目，就可以了 preset 配置 manually select features 手动的选择特性 rc —— run command 运行终端 vcs —— 版本控制系统 内容回顾 什么是cli 脚手架是什么东西 cli依赖webpack,node,npm 安装cli3-&gt;拉取cli2模块 cli2初始化项目的过程 cli2生产的目录结构解析","link":"/2023/05/09/vue-cli%E2%80%94%E2%80%94%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"title":"webpack","text":"详见下文 内容概述 认识webpack webpack的安装 webpack的起步 webpack的配置 loader的使用 webpack中配置vue plugin的使用 搭建本地服务器 什么是webpack 包含两个核心：模块 和 打包 打包工具：grunt/gulp/webpack 前端模块化 打包生成大部分浏览器可以识别的代码 不仅js可以模块化，css图片等都可以 处理各个模块之间的依赖，形成关系网 webpack支持前述各种模块化规范 打包：前端用的多的是webpack webpack和node和npm的关系 模块化开发-&gt;webpack模块化打包-&gt;打包文件放到服务器-&gt;用户访问浏览器访问服务器可以获取到内容 webpack为了正常运行，必须依赖node环境 node环境为了正常执行很多代码，需要很多依赖包 npm工具（node package manager）是安装node必备的，用来方便管理各种依赖包 webpack安装 webpack依赖node环境，所以先安装node(node版本不小于8.9) 使用node中的包管理工具npm安装webpack vue cli2 依赖 webpack3.6.0版本 -g 表示全局安装 webpack起步 项目重要文件 srcdist-&gt;distribution(发布) webpack会自动处理模块之间的依赖，所以只打包main.js的文件，其他的依赖关系交给webpack处理 开发流程(webpack基本使用)： src中使用模块化方式开发-&gt;使用webpack打包main中的代码到dist-&gt;把dist中代码引入index.html就可以显示开发的内容 webpack配置 配置打包路径——入口出口配置 想要更加智能的输入一个简单的指令就可以打包，而不是在命令行全部敲上从哪打包到哪 此时我们需要通过一个配置文件告诉webpack这系列操作 配置文件固定名——webpack.config.js npm init 执行后 生成 package.json，这个文件告诉我们当前项目里一些信息的 npm install 如果 package.json 中有依赖 会根据这个文件给项目安装依赖 如果要用到node的相关东西，要先建上package.json 我们要用到node里的path，path模块有个函数resolve可以对文件路径进行拼接 path.resolve(__dirname,’dist’)拿到绝对路径 __dirname是node上下文的一个全局变量，他保存的就是当前webpack.config.js这个文件所在的路径 webpack命令和npm run build命令映射 在package.json文件中scripts中添加build对应webpack，这样在命令行输入npm run build 时 执行的就是webpack这条命令 webpack本地安装配置 如果全局安装的webpack与本地克隆下来的项目的webpack版本不一致时，打包会报错 要配置webpack优先使用本地版本打包，此时本地需要安装webpack 执行命令npm install webpack@3.6.0 –save-dev 开发时依赖与运行时依赖，webpack只在开发时打包模块化文件，运行在服务器就没用了 如果直接在终端webpack此时用的是全局的webpack（除非找到wcj文件下再执行wbpk），而定义build脚本后运行npm run build则是优先在本地寻找wbpk版本，本地没有再去全局找 webpack核心概念之一——loader 为了项目运行时，css文件不单独一个个引用，一样打包到bundle.js文件中，到时候只引用这一个文件就能展示了，我们引入loader这个概念 样式loader的使用 按照命令安装 在config文件引用 css-loader只负责帮助你加载css文件，不负责解析css代码，也不会把css代码放到html中让样式生效 配置css文件的含义/ \\.css$/. 在正则中有特殊含义 所以 \\. 进行转义匹配.css^开始$结尾 less文件处理 步骤 创建less文件，些一些less代码 在main.js引用less文件 打包main.js 在index.html引用打包的js文件 测试代码是否执行成功 测试需要less的loader 安装less-loader和less 在webpack.config文件加上less规则 图片资源文件处理 创建图片文件 安装url-loader 配置图片文件 文件大小*1024比limit小——直接转成base64字符串文件 比limit大——要安装file-loader(不需要再配置) 会在dist文件下打包了一个图片文件，用哈希值命名的，为了不重复 如果安装后找不到图片路径要配置一下路径（publicPath:’dist/‘），保证引用打包后图片文件的路径正确 对图片命名进行规范 ES6语法处理——babel的使用 很多浏览器没有支持es6，适用性差 打包的时候es6都转为es5，最终bundle.js文件应该都是es5的语法 安装babel-loader、babel-core、babel-prest-es2015 配置相应规则 webpack配置vue 安装vue 引入vue，写一些vue代码 如果不配置 默认引入的vue文件是runtime-only这个版本不能用template 如果配置了地址 引入的就是runtime-compiler 可以有template 指定使用的vue文件路径 同时有el和template时，template中的内容整体替换#app的div .vue文件要安装两个东西 vue-loader —— vue文件加载vue-template-compiler —— vue编译 这俩仅开发时使用，加载编译完就不需要了 vue-loader 如果大于14（估摸）需要再装个插件才能运行，要不会报错让你安装那个插件 安装一个13多的版本就不报错了 .vue文件封装过程 以上loader就讲完webpack另一个核心——plugin 添加版权的plugin 打包html的plugin js丑化压缩的plugin 搭建本地服务器搭建服务器步骤 安装webpack-dev-server webpack的本地服务 配置devServer 12contentBase:'./dist',inline: true 配置 'dev': 'webpack-dev-server --open' 执行npm run dev 就会直接打开网页 base公共prod生产dev开发 webpack配置文件的分离base公共prod生产dev开发 公共和开发/生产 文件进行合并需要安装webpack-merge 文件路径配置——给文件起别名resolve 解决路径相关的问题extensions 导入文件后缀可省略alias 取别名‘@’:resolve(‘src’) 给src取个别名常用文件别名 当在DOM中标签引入取别名的路径必须要增加~ 扩充 文件夹组织方式 作为入口的main.js放在外层其他功能js代码放在文件夹中 bundle的意思是包 gitbook这个软件写的文档同步出去的会有这个网站名 非盈利组织的网站后缀叫org 盈利组织用com –save-dev 开发时依赖 早期dos操作系统文件后缀名只支持3位 所以jpg和jpeg是一个文件 htm就是html 现在windows系统可以支持很多位文件后缀 env就是environment环境的缩写 exclude排除include包含 vue项目最终会编译成2个版本 runtime-only 代码中不能有template runtime-compiler 可以有template，因为vue的代码有compiler可以编译template compiler编译的意思 后缀扩展名都不想写怎么配置 webpack.config.js中 extensions:[‘.vue’,’.js’,’.css’] 内容回顾 什么是webpack webpack和glup对比 webpack依赖环境 安装webpack webpack的起步 webpack命令 webpack配置：webpack.config.js/package.json webpack的loader css-loader/style-loader less-loader/less url-loader/file-loader babel-loader webpack中配置vue webpack的plugin 搭建本地服务器 webpack-dev-serve 配置文件的分离","link":"/2023/04/24/webpack/"},{"title":"作用域","text":"详见下文 定义 作用域:它是指对某一变量和方法具有访问权限的代码空间, 在JS中, 作用域是在函数中维护的。表示变量或函数起作用的区域,指代了它们在什么样的上下文中执行,亦即上下文执行环境。ES5的作用域只有两种:全局作用域和局部作用域(又名函数作用域) 123456789101112全局作用域var a=1; //全局作用域function fn1(){ console.log(a)};fn1()局部作用域function fn1(){ var a=1; //局部作用域};fn1();console.log(a); 生命周期：全局：浏览器关闭前都生效局部：仅在函数执行时生效，函数执行完毕回收 局部不断去享受父作用域的值，父享受不了子的值 123456789101112var a = 1; //全局作用域function f1(){ var b = 2; //局部作用域 b属于f1下的作用域 function f2(){ var c = b; //局部作用域 c属于f2下作用域 b = a; a = c; console.log(a,b,c) //2 1 2 }; f2();};f1(); 扩展 1234567891011121314151617181920212223242526272829303132333435//1)var a = 1;function f1(){ console.log(a);};f1(); //1//2)function f1(){ var a = 1;};f1(); console.log(a); //a is not defined//3)注意打印第二个avar a = 1;function f1(){ console.log(a); //1 a = 2; //改变全局变量的值};f1();console.log(a); //2//解析过程 //预解析var a;function f1(){}//逐行解析a = 1;f1();//函数执行console.log(a); //1a = 2;console.log(a); //2 全局变量和局部变量同名的坑(1)在全局变量和局部变量不同名时，其作用域是整个程序。(2)在全局变量和局部变量同名时，全局变量的作用域不包含同名局部变量的作用域。 1234567891011121314151617181920212223//4)var a = 1;function f1(){ console.log(a); //undefined var a = 2; //在全局变量和局部变量同名时，全局变量的作用域不包含同名局部变量的作用域。};f1();console.log(a); //1//解析过程 //预解析var a;function f1(){}//逐行解析a = 1;f1();//函数执行//预解析var a;console.log(a); ////undefineda = 2;console.log(a); //var a = 1; 1 123456789101112131415161718192021222324252627//经典作用域面试题一var a = 10; function f1(){ var b = 2 * a; var a = 20; var c = a+1; console.log(b); console.log(c); };f1();//解析过程 //预解析var a;function f1(){}//逐行解析a = 10;f1()//函数执行//函数内部的预解析var b;var a;var c;////逐行解析b = 2*a; //a = undefined 在全局变量和局部变量同名时，全局变量的作用域不包含同名局部变量的作用域a = 20;c = a+1;console.log(b); //NaNconsole.log(c); //21 12345678910//经典作用域面试题二var a=10; function test(){ console.log(a); //undefined a=100; //在全局变量和局部变量同名时，全局变量的作用域不包含同名局部变量的作用域 console.log(this.a); //this 指向window 10 var a; console.log(a); //100}test();","link":"/2023/03/23/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"函数式编程与面相对象编程","text":"详见下文 js是解释型或即时编译型的高级编程语言支持面相对象、命令式和声明式（函数式）编程风格 函数式写法 sum(){ return n1+n2} 面相对象写法（构造函数、ES6里的class类） 对象 字面量方式 好管理 复用过程中好引用不用一个个引入， 对象定义方式嵌套字面量写法简单字面量写法 案例——放大镜功能实现 12345678910111213141516171819202122232425262728293031函数式函数式的写法先会了再放到面向对象方式处理滑块的显示隐藏面相对象变更成面相对象的写法定义对象 字面量的方式var obj = { id:1, action:function(){}}this 指针在函数内部运行过程中会自动生成一个内部的对象this 指针只在函数内部生成this在回调函数、定时器等里面指向window面相对象变化2var obj = { $:function(){} init:function(){} mouseleave:function(){} mousemove:function(){}}分模块开发的思想代码要分块看最开始调用了什么这里面定义了什么","link":"/2023/03/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"title":"前端模块化","text":"详见下文 内容概述 为什么要使用模块化 简单写js代码带来的问题 闭包引起代码不可复用 自己实现了简单的模块化 AMD/CMD/CommonJS ES6中模块化的使用 export import 为什么有模块化这个概念 ajax异步请求出现，前端代码量增多 非模块化开发带来的问题，如定义同名全局变量 解决命名冲突问题——匿名函数，闭包，函数有自己的作用域 解决代码复用问题——模块化 常见模块化规范：CommonJS、AMD、CMD、ES6的Modules(ES5没有模块化概念，ES6加入了模块化概念) 模块化的核心：导入和导出CommonJS（了解）ES6模块化实现 实现过程 script标签加type=”modules”属性 导出export{a,b} import(a,b) from ‘a.js’ 导出 先定义后导出 导出直接定义 先定义函数后导出/直接导出函数 先定义类后导出/直接导出类 导出默认值export default 导入 导入{}中定义的变量 导入直接导出export定义的变量 导入 export的fun和class 导入 export default 中的内容 统一全部导入","link":"/2023/04/25/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"title":"原型是一个对象","text":"详见下文 原型：通过原型实现继承JS对象分两种普通对象object函数对象function__proto__是每个对象都有的属性prototype是函数才有的属性（原型只有函数才有的属性） 普通对象和函数对象的区别用typeof类型判断函数的实例化对象也是一个普通对象object 12345678function f1(){};// 构造函数typeof f1 //&quot;function&quot;var o1 = new f1(); // 实例化的是普通对象，不是函数对象typeof o1 //&quot;object&quot;var o2 = {};typeof o2 //&quot;object&quot; 构造函数 首字母大写 函数内部用到this 必须要对构造函数实例化处理 12345678构造函数(构造器) 类 抽象function Person(name,age){ this.name = name this.age = age}实例化var x = new Person('x',20)（实例化的是普通对象，不是函数对象 所以没prototype） 如果不实例化，就是构造的人，并非真实的人，梦中的人 为什么要用prototype？为什么要继承？创建多个对象 1234567891011var o1 ={ name:'o1', id:1, age:1,}var o2 ={ name:'o2', id:2, age:1,}// 缺点 实例太多写起来麻烦，且实例和原型没有关联（没有共享和公共）如果要添加属性和方法就很麻烦 封装一个函数 复用 12345678910function Cat(name,id,age){ return { name:name, id:id, age:age }}var o1 = Cat('o1',1,1)// 缺点 不知道实例是否来自同一个原型对象，不能知道是不是来自一个祖先，不能共享祖先带来的一些福利（继承他的属性和方法）// 优点 要添加属性和方法就很方便 构造函数 123456789function Cat(name,id,age){ //构造函数 this.name = name; this.id:id; this.color = color; this.type = '动物'; this.eat = function(){console.log('吃鱼')}};var cat1 = new Cat('o1',1,1); //实例化var cat2 = new Cat('o2',2,1); 优化构造函数 12345678910111213function Cat(name,id,age){ this.name = name; this.id:id; this.color = color; //this.type = '动物'; //this.eat = function(){console.log('吃鱼')}};Cat.prototype.type = '动物';Cat.prototype.eat = function(){console.log('吃鱼')};var cat1 = new Cat('o1',1,1);var cat2 = new Cat('o2',2,1);// 优点 实例都享受原型上的属性和方法（公共的提出来）都放在里面浪费内存，对每个实例来说这个方法和属性都是一模一样的，不环保，缺乏效率 重构？重构的是什么？考虑一些公共的功能提取出来 原型分解图 12341、每一个函数对象都有一个prototype属性，但是普通对象是没有的；prototype下面又有个constructor，指向这个函数。2、每个对象都有一个名为__proto__的内部属性，指向它所对应的构造函数的原型对象，原型链基于__proto__; 构造函数和原型对象的不同 1234567cat是构造函数，cat.prototype是构造函数的原型对象构造函数的属性和方法不能共享原型对象的属性和方法可以被所有实例对象去共享构造函数是生成对象的模板，一个构造函数可以生成多个对象，每一个对象会有相同的结构（属性方法）原型对象可以不断去定义你需要的资源（属性方法）（不浪费内存、环保） 验证属性方法是自身的还是原型对象的12345console.log('name' in p1); //in 不管自身的还是原型 都返回trueconsole.log('type' in p1);console.log(p1.hasOwnProperty('name')); //hasOwnProperty() 自身返回true 原型 返回falseconsole.log(p1.hasOwnProperty('type')); 继承的多种方式 读取对象的属性时优先读取自身的属性，如果找不到再去原型找，直到最顶的Object.prototype 如果对象自身和他的原型都定义了同名属性，优先取对象自身的属性 原型继承12345678910111213141516function Animal(){ //Animal构造函数this.type = &quot;动物&quot;};function Cat(name,color){ //Cat构造函数this.name = name;this.color = color;};Cat.prototype = new Animal();// 共有的动物特性提出来，凡是动物都可以享受其中属性，// Cat.prototype cat的原型对象 = new Animal()// 这样写让动物和猫产生了继承的关系var c1 = new Cat('x','白色');var c2 = new Cat('t','花色');c1.type优点：同一个原型对象缺点：不能修改原型对象，会影响所有实例 构造函数的继承 1234567891011121314151617function Animal(){this.type = &quot;动物&quot;};function Cat(name,color){Animal.apply(this); //将Animal对象的成员放到Cat对象上this.name = name;this.color = color;};var cat1 = new Cat(&quot;大明&quot;,&quot;黄色&quot;);var cat2 = new Cat(&quot;小明&quot;,&quot;白色&quot;);cat1.type = '我是黄猫';cat2.__proto__.type = '我是动物';console.log(cat1.type); //'我是黄猫' cat1被修改console.log(cat2.type); //&quot;动物&quot;优点：不存在修改原型对象影响所有实例，各自拥有独立属性缺点：父类的成员会被创建多次，存在冗余且不是同一个原型对象通过apply/call只能拷贝成员，原型对象不会拷贝 组合继承 123456789101112131415161718function Animal(){this.type = '动物'};Animal.prototype.eat = function(){console.log('吃')};function Cat(name,color){this.name = name;this.color = color;Animal.call(this);};Cat.prototype = new Animal();var cat1 = new Cat(&quot;大明&quot;,&quot;黄色&quot;);var cat2 = new Cat(&quot;小明&quot;,&quot;白色&quot;);cat1.type = '我是黄猫'; //修改当前构造器中的属性cat2.__proto__.type = '我是动物';//修改了原型对象的值，但并不影响cat1,cat2的值console.log(cat1.type); //'我是黄猫' //原型对象的值变化，并不影响构造函数值console.log(cat2.type); //'动物'console.log(cat2.__proto__.type); //'我是动物cat1.eat(); //还可以调用原型对象中eat()方法 原型是一个对象 ES5没有类类就是一个抽象的对象 ES6里可以用class定义类 那ES5里面怎么定义抽象的对象？构造函数？ 用原型实例指向创建对象的类 适用于创建新的对象的类时 共享原型的属性和方法原型是一个对象 其他对象可以通过它实现属性继承 原型为了实现属性继承出现的 JS里面一切皆对象 JS对象氛围两类普通对象object 函数对象function prototype是函数才有的属性__proto__是每个对象都有的属性 普通对象和函数对象区分用typeof类型判断 123456789101112131415161718构造函数function f1(){};//函数对象typeof f1 //&quot;function&quot;构造函数实例化var o1 = new f1(); //函数实例（函数的实例对象也是普通对象，并非是函数对象）typeof o1 //&quot;object&quot;var o2 = {};typeof o2 //&quot;object&quot;//普通对象 var o = {};//函数对象function f(){} // var f = function(){}//实例是普通对象var f1 = new f(); 具体原型的写法12345function Person(){}; //定义一个函数对象Person.prototype.name=&quot;abc&quot;; //原型对象中添加属性Person.prototype.action=function(){} //原型对象中添加属性var p1 = new Person(); //实例化 var p2 = new Person(); 构造函数（构造器） 首字母大写 里面会用到this变量1","link":"/2023/03/23/%E5%8E%9F%E5%9E%8B%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/"},{"title":"史上最全hexo博客搭建步骤详解","text":"我的第一篇博客，先给hexo~ 前言本篇讲解主要参考codesheep的关于hexo搭建的视频，结合自己踩的一些坑，综合各路大神的指南而成，如果你在实践本篇博文的过程中有任何问题，欢迎和我一起交流~ 搭建博客的目的： 明确我们的目标才不会让你半途而废 社招、校招加分项 追求极客范儿 挑战自己，我很棒 总览一下我们搭建hexo博客的步骤： 搭建node.js环境 安装加速包cnpm hexo安装 使用hexo搭建博客 新建第一篇博文 把博客部署到github 博客换肤以上就是博客搭建过程概览 下面我们按照上面的步骤逐一实现，你也可以拥有属于自己的博客哟~操作的过程中先不用问太多为什么，照做就行了 1、搭建node.js环境1.1 下载node.jshexo是node.js生成的，需要node.js环境 nodejs官网：nodejs.org nodejs官网图 建议：不要下载最新的node版本，我下载的12版本的 12版本list图 自动安装包格式.pkg 傻瓜安装，一直点同意就好了 安装的结果实际上安装了两个文件一个是node.js另一个是npm包管理器,这是搭建hexo必备 1.2 查看安装的node与npm版本 打开终端 12查看node版本：输入 node -v查看npm版本：输入 npm -v 这里codesheep是在root用户下操作的，但是到后面我使用编辑器操作文件会有点麻烦，总是需要root权限，所以这个因人而异吧 啰嗦一句~每次我们安装或者操作什么都要及时检查这个操作是否成功，程序员基操吧 2、安装加速包cnpm因为国内镜像源的安装速度慢，所以我们安装一个淘宝镜像源，为一会安装hexo速度快 2.1利用npm安装cnpm1输入 npm install -g cnpm --registry=https://registry.npm.taobao.org 2.2查看cnpm版本1输入 cnpm -v cnpm版本截图 3、hexo安装3.1用cnpm安装hexo1输入 cnpm install -g hexo-cli 3.2查看hexo版本1输入 hexo -v 图 4、使用hexo搭建博客4.1建一个空的文件夹blog这个文件夹是存放我们博客所有内容的，那么在建文件夹前先看一下我们当前的位置，方便后续寻找我们的blog文件夹在哪 1查看当前位置：输入 pwd 图 123新建blog文件夹：输入 mkdir blog进入blog：输入 cd blog查看当前位置：输入 pwd 此时我们的路径是/blog结尾，接下来是在这个blog文件初始化我们的hexo 4.2 初始化hexo1初始化hexo：输入 init hexo 此时可以看到克隆到了hexo文件和默认landscape主题 进入blog文件查看初始化都自动生成了哪些文件，后续我们写博客都基于这里面的文件，瞅一眼有啥就行 4.3启动博客1启动hexo:输入 hexo s 此时终端会出现 http://localhost:4000/ 表示我们再本地已经启动成功博客，点这个链接进来看看我们搭建的博客以上我们的博客就搭建完成了，是不是没那么难~ 博客有了我们开始写文章吧~5、新建第一篇博文5.1 创建博文1新建博文：输入 hexo n &quot;你的博文标题&quot; 可以看到我们的博文被创建到source/_posts目录下了，并且是.md格式的，到编辑器(我使用的是vscode)里面打开这个文件，开始写你的第一篇博文吧~ 5.2 查看你完成的第一篇博文写完之后，再次启动一下我们的博客，在本地查看我们新写的一篇博文 看下当前你的位置 1输入 pwd 我们后面的操作依然要回到blog文件下面 接着输入 hexo clean 清理一下 1输入 hexo g 生成一下 先不要问为啥，你以后会知道，照做 1输入 hexo s 启动 刷新刚打开的网址，可以看到我们刚写的博文已经出现了 6、把博客部署到github我们想要一个远端地址可以查看我们的博客，推荐github部署方式，免费万岁！ 6.1 创建github仓库网址：github.com 没有账号的自己注册，不赘述啦，毕竟我们的主题是hexo 登录进来 页面右上角，头像的左边👈🏻有个➕号，➕号下拉框里点New repository新建一个仓库 点进来填写Repository name 命名规范：你的用户名.github.io 你的用户名就是旁边的Owner里面写的 比如我的用户名：inie96 那么就是 inie96.github.io 用户部署个人博客的github仓库的命名必须是这个 点 Create repository 创建仓库完成 6.2 安装git部署插件终端进入到blog文件下 1安装git：输入 cnpm install --save hexo-deployer-git 6.3 设置blog文件下的_config.yml文件来编辑器里，找到blog文件下的_config.yml文件 最下面有个# Deployment 找到他 在他下面配置上这三行 1234type: gitrepo: git@github.com:inie96/inie96.github.io.git（这里配置成我们刚创建仓库的ssh地址，注意是ssh）branch: master 图 最终长这样 6.4 向github部署博客终端回到blog 输入 hexo d 接着会提示你输入github账号密码 部署完成后去刷新刚创建的github仓库，此时已经有文件进来了，就是部署成功了 把仓库名拿出来访问inie96.github.io就可以在远端查看博客了~ 以上我们的博客远端部署完成 7、博客换肤7.1 挑选皮肤网址：https://hexo.io/themes/ 7.2 进入喜欢的皮肤的仓库我选的是icarus 仓库地址：https://github.com/ppoffice/hexo-theme-icarus 7.3 下载主题回到终端blog下面 克隆/下载主题：输入 git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus themes/icarus 是我们要下载到的文件位置 此时在文件夹中打开这个路径就可以看到我们下载的主题文件 7.4 给我的博客配置icarus主题修改刚刚我们也改过的blog文件下的_config.yml文件 这个文件还蛮重要 1修改 theme: icarus 修改成themes下的icarus文件名 图 此时我们再次 123hexo cleanhexo ghexo s 在本地查看一下更换的主题 打开 http://localhost:4000/ 查看没有问题，推送到远端 1输入 hexo d 在远端地址查看更改后的皮肤，换肤完成 总结 安装node 安装cnpm 安装hexo 初始化hexo：init hexo 创建hexo博文：hexo n 部署hexo到github 创建github仓库 安装git 配置文件 hexo d 博客换肤 下载主题 git clone 配置文件 hexo d hexo四件套 1234hexo cleanhexo ghexo shexo d 欢迎观看~ 完结撒花~","link":"/2022/05/21/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3/"},{"title":"对象属性和方法","text":"详见下文 123456789101112//在真实生活中，汽车是一个对象。//汽车有诸如车重和颜色等属性，也有诸如启动和停止的方法var car = new Object(); //定义一个对象car.color='white'; //颜色属性car.weight ='1.5t'; //重量属性car.start = function(){ //启动的方法 console.log('启动')};car.stop = function(){ //停止的方法 console.log('停止')}; 1、定义对象的方式123456789101112131415161718192021222324252627//第一种 使用new var person = new Object();person.name = 'alice';person.age = '18';//定义属性的方式有二种，一种以.的方法 二种[]的方式person['age']= '18';person.sing = function(){ console.log('唱')};//第二种方式对象字面量//1)简单字面量var person2 = {};person2.name='jack';person2['age'] = '20';person2.action = function(){ return '我是一个对象'};document.getElementById(&quot;test&quot;).innerHTML = person2.action();//2)嵌套字面量 键名加不加引号是可行的 加引号：属性名字有空格 连接符- 保留字var person3 = { name:'amy', age:18, action:function(){ return this.name }};person3.action() ; //amy 2、属性的获取方式1234567891011121314151617181920212223242526//属性的设置有 . [] .是取自身的属性 []可以是变量var obj = {};obj.name = 'abc';obj['age'] = 20;obj.name;obj['age'];var a = 'age';obj[a]; //20 //枚举属性 for in 遍历对象的属性var obj2 = {name:'abc',age:18,id:1};for(o in obj2){ console.log(o) //获取键名 name age id console.log(obj2[o]); //获取value值 };var arr = ['a','b','c'];for(a in arr){ console.log(a) //得到是索引 0123};//序列化 数据 json字符串的方式来传输 //对象转json字符串 JSON.stringify()//json字符串转对象 JSON.parse()var obj3 = {name:'abc',age:18,id:1};console.log(typeof JSON.stringify(obj3)) //stringconsole.log(typeof obj3); //objectvar str = JSON.stringify(obj3);console.log(typeof JSON.parse(str)); //object 3、对象常用方法123456789101112131415161718192021222324252627282930313233343536373839//hasOwnProperty() 该方法可以判断对象的自有属性是否存在 检测var o = { flag:'a'};o.hasOwnProperty('flag') //返回的结果是布尔 满 足条件true 反之false//assign() 该方法主要用于对象的合并var o2 = {name:'abc',age:18};var o3 = {id:1,address:'武汉'};var o4 = Object.assign(o2,o3);console.log(o4) //{name: &quot;abc&quot;, age: 18, id: 1, address: &quot;武汉&quot;}var o5 = {flag:'a',address:'北京'};console.log(Object.assign(o4,o5)) ;//当属性相同时，后面会覆盖的属性值，属性不相同添加属性//{name: &quot;abc&quot;, age: 18, id: 1, address: &quot;北京&quot;, flag: &quot;a&quot;}//defineProperty()直接在一个对象上定义新的属性或修改现有属性，并返回该对象。var o6 = {};Object.defineProperty(o6,'name',{ value:'张三', writable:false //属性是否可以修改 true可以修改 false只读 });//定义多个Object.defineProperties(o6,{ 'name':{ value:'abc', writable:false }, 'age':{ value:18, writable:false }});o6 //{name:'abc',age:18}//keys() 返回一个由一个给定对象的自身可枚举属性组成的数组var o7 = {name:'abc',age:18};var a2 = Object.keys(o7); //返回的是数组 [&quot;name&quot;, &quot;age&quot;]//values();返回一个给定对象自己的所有可枚举属性值的数组var a3 = Object.values(o7) //[&quot;abc&quot;, 18]//entries();返回一个给定对象自身可枚举属性的键值对数组var a4 = Object.entries(o7) //[[&quot;name&quot;, &quot;age&quot;],[&quot;abc&quot;, 18]] 1234567forforEachmap的区别需要返回值map不需要返回值forEach","link":"/2023/03/23/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"},{"title":"异步编程解决方案-Promise","text":"一篇搞定Promise~ 定义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓 Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。解决 JS中多个异步回调难以维护和控制的问题 Promise 对象有以下两个特点 对象的状态不受外界影响。 Promise 对象代表一个异步操作，有三种状态： pending （进行中）、 fulfilled （已成功）和 rejected （已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承 诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。基本用法Promise 对象是一个构造函数，用来生成 Promise 实例。123456789101112var p = new Promise(function(resolve,reject){ if(true){ //请求成功 resolve('ok') }else { reject('error') }});p.then(function(res){ console.log(res)},function(res){ console.log(res)}) 解释Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。解决回调陷阱12345678910111213141516171819202122let p = new Promise(function(resolve, reject){ if (true){ resolve(&quot;成功&quot;); } else { reject(&quot;失败&quot;); }})p.then(function(v){ return new Promise(function(resolve, reject){ if (true){ resolve(&quot;成功&quot;); } else { reject(&quot;失败&quot;); } })}, function(v){ console.log(v)}).then(function(){ console.log(4)}, function(){ console.log(5)}) Promise.all()Promise.all() 方法用于将多个 Promise 实例，包装成一个新的Promise 实例。1const p = Promise.all([p1, p2, p3]); Promise.all() 方法接受一个数组作为参数， p1 、 p2 、 p3 都是 Promise 实例，如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all() 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是Promise 实例。p 的状态由 p1 、 p2 、 p3 决定，分成两种情况。 只有 p1 、 p2 、 p3 的状态都变成 fulfilled ， p 的状态才会变成 fulfilled ，此时 p1 、 p2 、p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1 、 p2 、 p3 之中有一个被 rejected ， p 的状态就变成 rejected ，此时第一个被 reject的实例的返回值，会传递给 p 的回调函数。 实例： 12345678910111213141516var p1 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('1111') },1000)});var p2 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('22222') },4000)}); Promise.all([p1,p2]).then(([d1,d2])=&gt;{ console.log(d1,d2);},err=&gt;{}); Promise.race()1const p = Promise.race([p1, p2, p3]); 只要 p1 、 p2 、 p3 之中有一个实例率先改变状态， p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。Promise.race() 方法的参数与 Promise.all() 方法一样，如果不是 Promise 实例，就会先调用下面讲到的 Promise.resolve() 方法，将参数转为 Promise 实例，再进一步处理。 123456789101112131415var p1 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('1111') },1000)});var p2 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('22222') },4000)});Promise.race([p1,p2]).then(d =&gt;{ console.log(d);},err=&gt;{});","link":"/2022/08/13/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Promise/"},{"title":"扩展运算符","text":"详见下文 扩展运算符定义1.字面量是三个点（…）2.是rest参数的逆运算，将一个数组或者对象转为用逗号分隔的参数序列3.主要用于函数调用（太针对性了） 案例——数组的合并 1234567891011121314151617181920var arr1 = [1,2,3];var arr2 = [4,5];ES5方式arr1.concat(arr2);ES6方式法1var arr3 = [...arr1,...arr2] // arr3 [1,2,3,4,5]//...arr1 &lt;=&gt; 1,2,3//数组名前面带...就说明是把数组里面的值取出来了法2var arr4 = arr1.push(...arr2) // arr3 [1,2,3,4,5]不带...的错误拼接方式 变成了二维数组var arr5 = [arr1,arr2] //[[1,2,3],[4,5]]var arr6 = arr1.push(arr2) //[1,2,3,[4,5]]这种方式也是可以的var arr7 = [...arr1,...arr2,...[6,7]]//[1,2,3,4,5,6,7] 为什么和rest参数是逆运算？rest参数用于获取函数的多余参数rest 非数组-&gt;数组扩展运算符 数组-&gt;非数组 参数案例——定义的函数是计算参数的和 12345function sum(n1,n2){ return n1+n2};var arr6 = [10,20];sum(...arr6) //==sum(10,20) 扩展运算符与参数结合案例 1234567function f1(...value){ //...value rest 参数 console.log(value); //[-1,1,2,2,3] console.log(...value); //-1,1,2,2,3};let x1 = [1,2];f1(-1, ...x1, 2, ...[3]); //...x1,...[3] 扩展运算符//f1(-1,1,2,2,3) 扩展运算符与箭头函数结合案例 12345678910111213141516171819202122//面试题 扩展一 求数组对象中ID的最大值var arr7 = [ {id:1,name:'a',date:'2021-06-16',msg:'a'}, {id:2,name:'a',date:'2021-06-16',msg:'a'}, {id:5,name:'a',date:'2021-06-16',msg:'a'}, {id:8,name:'a',date:'2021-06-16',msg:'a'}, {id:3,name:'a',date:'2021-06-16',msg:'a'}];ES6写法var maxId = Math.max(...arr7.map(v=&gt;v.id)); // 8步骤分解1.求最大值使用Math.max(1,10)，注意括号中的值是逗号拼接2.取出ID的值 用循环遍历（此处用了map，map与forEach的区别：map有返回值）var a = arr7.map(function(v){ return v.id});console.log(a); // [1, 12, 5, 8, 3]Math.max(...a);3.把数组中值取出 用扩展运算符4.合并步骤 扩展运算符与解构结合案例 123456const [first, ...rest] = [1, 2, 3, 4, 5];console.log(rest) //[2, 3, 4, 5]const [first, ...rest] = [];console.log(first) //undefinedconsole.log(rest) //[] 扩展运算符与深拷贝（仅针对一维数组）案例 1234567891011非扩展运算var a1 = [1,2,3];var a2 = a1;a2[1] = 100;a1 //[1,100,3]//扩展运算var a1 = [1,2,3];var a3 = [...a1];a1[2] = 999;a3 // [1, 2, 3] 对象中扩展运算案例 12345678910111213141516171819202122232425var o1 = {id:1};var o2 = {name:'o2'};var o3 = {...o1,...o2}; //{id: 1, name: &quot;o2&quot;}var o4 = {...o1,o2}; //{id:1,o2:{name:'o2'}}// Vue3应用// setup(){// return {// ...state,// ...abc,// change// }// }var o1 = {id:1};var o2 = {name:'o2'};let f3 =() =&gt;999;var o6 = {...o1,...o2,f3}var o6 = { id:1, name:'o2', f3:function(){ return 999 }}","link":"/2023/03/23/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"数据类型","text":"详见下文 数据类型 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、空对象（Null）、未定义（Undefined）引用数据类型(复杂类型 )：对象(Object)、数组(Array)、函数(Function) 123var x;var x = 5; //声明变量名x 把5的值赋给xvar x ='5'; 基本类型字符串12345678可以在引号中添 加任意文本，命名用单引号或双引号var a = 'a';var b = &quot;b&quot;;var c = &quot;hello world&quot;;var x = '5';var name = '张三';var a = c; //c没有添加引号，表示变量C 所以a的值为&quot;hello world&quot;//alert(a); 数字12var n = 10;var n2 = 10.5; 布尔123只有二个值，true(真)和false(假) 用于条件判断var b1 = true;var b2 = false; 空对象12只有一个值nullvar _n = null; 未定义123var unde;var _unde = undefined;//alert(unde); 复杂类型数组（Array) 存储数据1234567891011121314var arr = new Array(); // 需要通过new关键字来声明其类型arr[0]='a';arr[1]= 2;console.log(arr); // [&quot;a&quot;, 2]//另一种方式var a1 = 'a';var arr2 = new Array(a1,'b',3,5);console.log(arr2); // [&quot;a&quot;, &quot;b&quot;, 3, 5]//简写var c = 'hello world'var arr3 = ['a','c',c,10,11];console.log(arr3[2]) // 获取方式arr3[索引] 结果&quot;hello world&quot;; 对象object1234567891011121314151617181920212223//由花括分隔 对象的属性以键和值的方式来定义{key:value} {name:'amy'}var person = new Object(); // 定义一个人物对象person.name = 'amy'; // 人物对象中添加了姓名属性 'amy'相当于是属性的值person.age = 18;console.log(person); // {name: &quot;amy&quot;, age: 18}//字面量的方式var person2 ={ name:'john', age:20, height:'175cm', weight:'65kg'};//获取对象属性值（两种方式）person2.name; //'john';person2['age']; //20//函数 function 函数是包裹在花括号中的代码块 使用关键词 functionfunction test(){ console.log(c);}test(); //调用的方式 结果&quot;hello world&quot;;","link":"/2023/03/23/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"数组常用属性和方法","text":"最近因为基础卡住了，补课~ 创建数组 new关键字方式12//使用 JavaScript 关键词 newvar color= new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;); 字面量方式12//使用数组文本创建var color2 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; 在数组中添加值与获取值123456789//数组中添加值color2[3] = 'abc';color2[4] = 'xyz';//获取color2[3] ;//'abc';//获取数组最后一个元素color2[color2.length-1];//获取数组长度color2.length; //5 数组中的方法数组转字符串 如果转成【逗号】号拼接，这个最简单 123//toString() 把数组转换为数组值（以逗号分隔）的字符串。var arr1 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr1.toString(); //&quot;red,blue,green&quot; 如果想用其他符号拼接，用这个 1234//join() 方法也可将所有数组元素结合为一个字符串，可以自定义分隔符var arr2 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];console.log(arr2.join(&quot;:&quot;)) //red:blue:greenconsole.log(arr2.join(&quot; &quot;)) //red blue green 增删改数组元素 添加新元素 在开头添加123//unshift() 方法（在开头）向数组添加新元素 var arr3 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr3.unshift(&quot;abc&quot;);//[&quot;abc&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] 在结尾添加12//push() 方法（在数组结尾处）向数组添加一个新的元素arr3.push(&quot;xyz&quot;); //[&quot;abc&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;,&quot;xyz&quot;] 删除元素 从后面删123//pop() 方法从数组中删除最后一个元素 pop()返回的是被弹出的值var arr4 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr4.pop(); //&quot;green&quot; arr4 ======[&quot;red&quot;, &quot;blue&quot;] 从开头删12//shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引，返回的是被弹出的值arr4.shift();//&quot;red&quot; 修改元素1234567891011//splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素则返回的是含有被删除的元素的数组var arr5 = [5,6,7,8];// arr5.splice(位置,个数,添加的新元素)arr5.splice(1,1); //删除了6 arr5 的结果是[5,7,8]arr5.splice(1,0,9);//arr5 的结果是[5, 9, 6, 7, 8]arr5.splice(1,2,3);//arr5 的结果是 [5, 3, 8]//slice()返回一个新的数组，包含从 start 到 end （不包括该元素）的arrayObject 中的元素var arr6 = [5,6,7,8];arr6.slice(1,3) //[6, 7]//arr6 仍然还是[5,6,7,8]; 返回的是选定的元素，该方法不会修改原数组 合并数组12345//concat() 方法用于连接两个或多个数组 该方法不会改变原有的数组var arr7 =[1,2,3];var arr8 = [4,5,6];var arr9 = arr7.concat(arr8);//arr9 [1, 2, 3, 4, 5, 6] 排序123456789//sort()排序var arr10 =[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr10.sort(); // [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;]var arr11 = [1,10,5,12,4,9,22];arr11.sort();// [1, 10, 12, 22, 4, 5, 9]//reverse() 方法用于颠倒数组中元素的顺序 会改变原数组arr11.reverse();// [22, 9, 4, 12, 5, 10, 1] 遍历数组for循环1234567891011121314//for循环遍历var arr12 =[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];var str = &quot;&quot;;for(var i=0;i&lt;arr12.length;i++){ str += &quot;&lt;p&gt;&quot;+arr12[i]+&quot;&lt;/p&gt;&quot;};document.getElementById(&quot;test&quot;).innerHTML= str;//forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。var arr13 =[1,2,3];var a14=[];arr13.forEach(function(item,index){ //item=1 2 3 a14.push(item+1);});console.log(a14); 筛选数组12345678910111213141516171819//filter()对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的组var arr15 = [2,3,5,6,7,18,9];var a15 = arr15.filter(function(item,index){ return item &gt;5; //满足的条件 大于5的结果[6, 7, 18, 9]});类似于&amp;&amp;//every()对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true//每一项都满足条件时返回true,只要有一个不满足返回falsevar a16 = arr15.every(function(item,index){ //return item &gt;5; //必须要求每一个数字都&gt;5才会返回true 否则 false return item&gt;1; //true});类似于||//some()只要有一个满足返回true,都不满足返回falsevar a17 = arr15.some(function(item,index){ //return item &gt;5; //只要有一个满 足了条件，返回true return item==0; //false 都不满足 返回false});","link":"/2022/05/29/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"},{"title":"最近的一点感悟","text":"最近工作很累，至于为什么累呢，我想到几个原因 心态 把心态拿到第一点来说，是因为它真的太重要了，好的情绪可以让你事半功倍，做事情都十分有效率，每个人都会遇到困难与挑战，就看你怎么去面对它，用乐观积极的心态去看待问题，可能暂时解决不了问题，但是会让心情放松，在一定程度上是好的，在这种心态下解决问题也会顺利，如果是很丧的，你周围的气压都是不一样的，自己的心情都是郁闷的，自然做起事来，只要有一点没有做好，就会给自己施压，消极的情绪就放大了，事情也变得糟糕难以解决了，试想你自己都厌恶自己，又有谁愿意与你一起共事呢，自爱才能他爱，所以要训练自己调节心态的能力。 这个项目才中点，我的情绪已经崩了两次了，实在是不应该，我很欣赏我对面的两位前端兄弟，记得有一次他们打开禅道，在打赌说谁bug多一些，bug多的那个人请喝饮料，打开一看，一个人120多个bug，另一个人70多个，本来不太热的办公室，我看到他们俩开始用本子扇起风来，那动作那么的一致（因为两个人都是胖胖的，又一起扇风，难兄难弟的感觉）看得我觉得有趣，于是我问，你们热吗，怎么还扇起来”扇子“了，我对面那个兄弟回答道：你看到这么多bug你不上火吗，我：哈哈哈哈哈。面对困难的不止我一个人，用调侃的方式去看待这些问题何尝不是一件好事呢，总归，不管用什么方式，问题一定是可以解决的，技术层面达不到那就寻求人为层面的方式，这需求实现不了~哈哈。 交流 有一段时间我认为交流毫无用处，写代码就写呗，好好思考技术问题，总是说、交流写的完么？交流那么多干什么？甚至不喜欢的人就不想去交流，除非必须要我去交流的事情我才会去交流，其他的时候就让我得测试代劳去沟通，可能因为关系还不错，我的测试大部分时候已经默认了这种行为。我得一位同事是从别的项目组来的，他因为不熟悉这个项目组的成员，慢慢的也变得和我一样，但是他说起来他之前的项目组，项目经理会把项目成员叫一起开会沟通，其实也和我们差不多，我们也会在项目开始的时候开会沟通，至于在项目过程中是如何操作的，那就不太清楚了，可能以后还会再和他交流相关的话题。这样发生的问题还是有一些的，自己思考难免陷入僵局，或者走进死胡同，而且还有和测试一起合谋漏掉需求的时候，最后被项目经理问起来也是很尴尬的。 让我走出交流无用认知，还是发生了一些事情的，比如遇到了问题自己想了很久也没有想明白，和同事讲了一下，可能好的解决办法并不是用更复杂的技术问题去解决他，换一种思考方式就好解决了，比如同事遇到了问题，向我寻求帮助，我这个局外人很容易看出来问题出在需求，让同事去沟通一下，问题也很好解决了，比如你做过一个需求，当然也是花时间研究过的，同事没有做过这种需求正在挠头，你的几句点拨就让他豁然开朗了，同事就可以按时下班了😏而且和有趣的人交流也可以放松心情，抚慰心灵，下一次你遇到困难的时候不妨和身边的人聊聊天，休息一下，就这一小会儿并不会耽误什么时间，可能正因为这样小小的放松休憩，接下来的工作就会迎刃而解了。 以上的心态和交流的问题如果解决了，其实可以节省出来大量的时间，这次项目我反而是因为这两者浪费了很多时间，还导致了项目延期🤭 难点 拿到我不熟悉的项目确实让我有一些压力，商城应该算to c类型的项目吧，总体来说绘制页面并不是很难，倒是组件和数据结合的时候，我懵了，因为在绘制组件的时候，我还是没有看接口文档的，具体数据结构是什么，在绘制页面的过程中我认为只要能按我写的数据渲染到页面上，到时候调接口我怎么也是可以把他拼成我现在写的这样的是吧，实践过程中有些是可以这样的，当然还是在心态好的时候更容易写出来，心态不好的时候居多，还有一些可能是对需求的理解不是很深入，不想交流，封闭自己，上面也说了，面临的事情不言而喻了。 页面绘制中，像带缩略图的swiper、列头带下拉框的table、table树、富文本、照片墙、标签组可单选复选、页面结构拆的要多细、组件封装的程度、多级路由出口在哪里、权限配置等等，这才只做了一半，很多问题都显现出来了，要思考的东西很多，之后要思考的东西也很多，想要做完项目好好的来一个总结的，在过程中先把稀碎的点记录下来。 接口联调中，如何熟练运用接口的组合，可能后端提供的方式并不是最适合前端的，怎样合理的运用接口，这是其中一个问题遇到的状况，还有的时候是缺乏沟通错误的运用了接口，造成一些逻辑还要重写，树形数据结构递归，树的子节点拼接，遍历嵌套数据，键与值结构的花样变换，对UI组件的熟悉程度，对Vue原理的熟悉程度，对webpack的熟悉程度，对路由守卫的熟悉程度等等技术问题也需要去思考。 写在最后 从21年6、7月进入项目组，前期运维工作居多，那个时候也没有和项目组的成员坐到一起，一直都是远程交流的，刚进来有一点不熟悉，但是也很快克服了那个阶段，后面又接了一些项目，比之前有一定难度，但是项目结构大致差不多，有难点却不那么集中，有思考分析的时间，所以倒也没有那么难，再到这个项目前后台两端，还是我第一次接触，对我技术成长有很大的帮助，短时间内要集中解决众多难点，还是有挑战。 虽然项目过半，我没有按期完成，但是通过这次的总结，我明白了应该怎么去做好后面的工作，而且在工作中每一个小小的进步都会让我发自内心的开心与肯定自己，正如墨菲定律中的不值得定律说的那样：“一个人如果在做一件自认为不值得做的事情，即使成功，也不觉得有多大的成就感；如果在做自认为值得做的事情，则会认为每一个进展都很有意义。”朋友圈中有的朋友会吐槽工作、领导多么的sb，有的朋友会发自内心热爱和表达出对工作的热情与喜爱，我想我应该是后者吧，也许有坎坷和苦闷，排除之后留下的更多是开心，我也不悔工作这三年的选择。 在项目中也交到了朋友（最近也零零散散的在看和交友有关的视频和书籍），一位忠实的良师益友比任何财富都重要，感谢协助我搭建博客的朋友，支持鼓励督促我变得更好的朋友🥰 我更应该好好培植与爱护我的“果树”。 想把这个项目作为我在这里三年的最后总结，抱着好好道别的心态，多么不想搞砸的，也可能是给自己的压力过于大了，越想做好的事情越紧张，反而并没有想象中那么好了。过去已然过去了，一万年又太久，只争朝夕吧~","link":"/2022/06/02/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/"},{"title":"深拷贝与浅拷贝","text":"90%公司都会问的JS进阶课程 深浅拷贝深拷贝：把你电脑的安装文件给我一份，你的文件改变不会对我有影响 浅拷贝：复制一份快捷方式，快捷方式放在任何地方都是指向的同一个对象 基本类型与引用类型？基本类型是深拷贝的，存在栈内存引用类型放在堆内存中，栈内存只是存放了引用地址 案例 基本类型——深拷贝 123456var a1 = 1, a2= a1;console.log(a1) //1console.log(a2) //1a2 = 2; //修改 a2console.log(a1) //1console.log(a2) //2 案例 引用类型——浅拷贝 123456var o1 = {x: 1, y: 2}, o2 = o1;console.log(o1) //{x: 1, y: 2}console.log(o2) //{x: 1, y: 2}o2.x = 2; //修改o2.xconsole.log(o1) //{x: 2, y: 2}console.log(o2) //{x: 2, y: 2} 什么是堆？什么是栈？计算器语言有一个处理的过程，写的代码会进行解释或编译执行，这个过程是在内存中，内存的使用和分配，涉及到堆和栈任何语言都有堆和栈 ，堆和栈都存放在内存中 栈：javascript的基本类型就5种:Undefined、Null、Boolean、Number和String，它们都是直接按值存储在栈中，每种类型的数据占用的内存空间的大小是确定的栈由系统自动分配, 例如，声明在函数中一个局部变量var a; 系统自动在栈中为a开辟空间只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出 堆：javascript中其他类型的数据被称为引用类型的数据 : 如对象(Object)、数组(Array)、函数(Function)…，它们是通过拷贝和new出来的，这样的数据存储于堆中其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。 不懂深浅拷贝的危害90%企业问深浅拷贝代码不规范新人不懂，写代码帮倒忙改变全局会有很大影响，需要私有修改 引用类型如何实现深拷贝? 数组用slice和concat方法可以深拷贝 1234var arr =[1,2,3]var arr2 = arrarr2.push(5)console.log(arr)//[1,2,3,5] 案例——slice 1234var arr =[1,2,3]var arr2 = arr.slice(0)arr2.push(5)console.log(arr)//[1,2,3] 案例——concat 1234var arr =[1,2,3]var arr2 = arr.concat()arr2.push(5)console.log(arr)//[1,2,3] 注意：以上只针对一维数组！！ 对象案例——创建一个新对象 123456789101112var obj={ name:'diane', age:18}var obj2 = new Object()obj2.name = obj.nameobj2.age = obj.ageobj.name = 'jack'console.log(obj) // {name: 'jack', age: 18}console.log(obj2) // {name: 'diane', age: 18} 注意：…这种方式也是浅拷贝不是深拷贝！！ 案例——Object.assign()实现深拷贝 123456var obj1 = {a:1,b:2}var obj2 = {b:10,c:20}Object.assign(obj1,obj2)console.log(obj1) // {a:1,b:10,c:20}Object.assign()作用是对属性进行重新分配的，用来把两个对象合并到一块，后面的属性值覆盖前面的，合并到前一个对象中 1234567891011121314var obj1 = {a:1,b:2,sub:{c:3}}function f(o2){ var o = {} Object.assign(o.o2) return o}var a =f(obj1)obj1.a =99a.sub.c = 'aaaaa'console.log(obj1) // {a:99,b:2,sub:{c:'aaaaa'}}console.log(a) // {a:1,b:2,sub:{c:'aaaaa'}}这是典型的浅拷贝，一级是深拷贝，嵌套在里面的是浅拷贝判断深浅拷贝就要看对象中的嵌套对象、嵌套函数拷贝后是否保持原样不丢失 序列化数据交互、数据传输 对象是不行的 bejson.com 格式化校验工具 12345678910JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串var obj = {name:'a',age:20};console.log(typeof JSON.stringify(obj)) JSON.parse() 方法用于将一个 JSON 字符串转换为对象var obj = {name:'a',age:20};var str = JSON.stringify(obj);console.log(typeof JSON.parse(str)) 用序列化实现深拷贝1var new_obj = JSON.parse(JSON.stringify(obj)) 案例——序列化深拷贝 123456789101112var obj={ name:'diane', age:18, o2:{ id:1 }}var obj2 = JSON.parse(JSON.stringify(obj))obj.o2.id = 3console.log(obj) //{age: 18,name: &quot;diane&quot;,o2: {id: 3}}console.log(obj2)//{age: 18,name: &quot;diane&quot;,o2: {id: 1}} 案例——缺点 123456789JSON.parse(JSON.stringify(obj))深拷贝的坑利用JSON.stringify 将js对象序列化 （JSON字符串），再使用JSON.parse来反序列化还原js对象注意以下几点：1.如果obj里面存在时间对象，JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。2.如果obj里有RegExp、Error对象，则序列化的结果格只得到空对象。3.如果obj里有函数，undefined，则序列化的结果会把函数，undefined丟失。4.如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。5.JSON.stringify()只能序列化对象的可枚举的自有属性，如果obj中的对象是由构造函数生成約，则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丟弃对象的constructor。6.如果对象中存在循环引用的情况也无法正确实现深拷贝。 深拷贝终极方案深拷贝的封装写法此方案用到了递归了解一下什么是递归？程序调用自身的编程技巧称为递归，在运行的过程中调用自己 1234567891011121314151617181920212223242526//封装一个方法 deep来实现对象的深拷贝var Animal={ name: &quot;duobi&quot;, skin: [&quot;red&quot;, &quot;green&quot;], child: { xxx: &quot;xxx&quot; }, say: function(){ console.log(&quot;I am &quot;, this.name, &quot; skin:&quot;, this.skin) }}function deep(dest, obj){ var o = dest; for (var key in obj) { // typeof不管是数组还是对象返回都是object if (typeof obj[key] === 'object'){ // constructor用来判断类型是数组还是对象 o[key] = (obj[key].constructor===Array)?[]:{}; deep(o[key], obj[key]); } else { o[key] = obj[key] } } return o;};var x = deep({},Animal); // 调用 总结：如果面试官问你深浅拷贝，这样吊打他1231. 告诉他底层原理，数据是堆内存、栈内存存储的2. 用以上存储方式的数据数据结构：基本数据结构和引用数据结构3. 深浅拷贝的含义","link":"/2022/09/08/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"title":"路由","text":"详见下文 路由 概念 路由是网络工程里面的一个术语 路由是通过互联的网络把信息从源地址传输到目的地址的活动——维基百科 联系生活——路由器 生活中能想到的就是路由器 路由器的两个机制：路由和转送 路由 是决定数据包从来源到目的地的路径 转送 将输入端的数据转移到合适的输出端 路由有一个非常重要的概念是路由表 路由表本质是一个映射表，决定数据包的指向 家庭联网场景: 移动公司→接一个猫（有个公网IP）→连家里路由器→家中各个联网设备（路由器给分配内网IP） 路由器中的映射表 [ 内网IP:设备的唯一标识（电脑的mac地址/手机的标识地址） …] 前后端渲染 前后端路由 后端路由阶段 后端渲染也叫服务器渲染浏览器向服务器请求URL对应的页面服务器通过一些技术jsp+html+css+java 从数据库获取数据，并动态的将他放在页面中，再把处理好最终的网页返回给浏览器浏览器展示的就是html+css 后端处理url和页面之间的映射关系 所以是后端路由 一个网站有那么多页面，服务器是如何处理的？一个页面有自己对应的网址，也就是URL客户端把URL发送到服务器，服务器通过正则对URL进行匹配，最后交给一个controler处理controler进行各种处理最终形成HTML或者数据返回给前端这就完成了一个IO操作 以上操作就是后端路由当请求不同路径的内容时，交给服务器进行处理，服务渲染好珍整个页面，并将页面返回给客户端这种情况下渲染好的页面，不需要单独加载js和css，可直接交给浏览器展示，这样有利于SEO优化 后端路由的缺点整个页面的模块由后端编写和维护前端人员如果开发页面需要通过PHP或者Java等语言来编写页面HTNL代码和数据和相关逻辑会混在一起，编写和维护都很糟糕 前后端分离阶段 后端只负责提供数据，不负责任何阶段的内容 客户端输入url到静态资源服务器请求html+css+js静态资源服务器放了好几套html+css+js对应url浏览器执行js代码，遇到执行网络请求的代码去api接口服务器请求对应数据，在通过js代码创建元素插入数据，渲染到页面上 以上过程就是前端渲染浏览器中显示的网页中的大部分内容都是由前端写的js代码在浏览器执行，最终渲染出来的 随着ajax的出现，有了前后端分离的开发模式 后端只提供API来返回数据，前端通过AJAX获取数据，并且可以通过js将数据渲染到页面上 这样做最大的优点就是让前后端责任清晰，后端专注于数据，前端专注于交互和可视化 并且当移动端（ios/android）出现后，后端不需要进行任何处理，依然使用之前的一套API即可 目前很多网站依然采用这种模式开发 单页面富应用阶段 SPA最主要的特点是在前后端分离的基础上增加了前端路由也就是前端来维护一套路由规则 SPA 就是 simple page web application 单页面富应用整个网站只有一个html页面 在静态资源服务器只有一套html+css+js 客户端输入URL到静态服务器请求全部资源——一套html+css+js 但是不会全渲染出来前端路由做支撑，点一个页面会生成一个url，生成的url不会像静态服务器请求资源会从全部资源抽取要显示的展示出来改变一个url就会从全部资源找到一个组件的资源渲染出来 前端路由就是映射url和全部资源之间要渲染哪个组件的前端管理url和组件间的关系 前端路由的核心改变URL，页面不进行整体刷新如何实现？ 改变URL页面不整体刷新的实现 URL的hash值 URL的hash也就是锚点#，本质上是改变window.location.href属性 通过直接赋值location.hash来改变href，但是页面不进行刷新 html5的history模式：pushState history.pushState({},’’,’/foo’) 入栈 本质是把这个地址压入栈内 history.back() 出栈 还有 replaceState 替换 不能返回 pushState 中还能用 go(-1) history.forward() go(1) 验证方式 可以看页面有没有进行网络请求静态资源 安装和使用vue router 安装1npm install vue-router --save –save是因为运行在客户端的时候也需要路由 在模块化工程中使用（因为是一个插件，所以可以通过vue.use()来安装路由功能）搭建路由框架 第一 导入路由对象，调用vue.use(VueRouter) 第二 创建路由实例，并传入路由映射配置 第三 在Vue实例中挂载创建的路由实例 使用vue-router的步骤配置映射关系 第一 创建路由组件 第二 配置路由映射：组件和路径之间的映射关系 第三 使用路由：通过router-link和router-view 一个映射关系就是一个对象 12path:'',component:null router-link是vue中注册过的组件，最终会被渲染成a标签 路由重定向redirect 路由模式更改为history默认情况下，不传mode就是hash模式想改变就传参 router-link补充 tag replace active-class 局部修改样式命名 全局修改样式命名 代码方式修改路由——$routervue给所以组件都加了一个属性$router不要绕过路由去处理路径变化 如用pushStatepush=&gt;pushStatereplace=&gt;replaceState 动态路由 配置路由组件映射关系加上动态属性 跳转配置拼接相关属性值 跳转到的页面拿取url拼接属性值 打包文件解析 vue会把我们的js文件打包到3个文件中 app是我们写的业务相关代码 manifest是底层支撑依赖的代码 vendor是第三方软件支撑代码如 vue vue-router 插件等等 路由懒加载用到时再加载 懒加载效果就是 路由动态引入 业务逻辑文件分别打包到js文件中(一个路由懒加载会对应一个打包的js文件) 现在都用第三种路由懒加载方式 嵌套路由 嵌套路由配置默认路径 路由传参 params query router-link方式 函数式方式 URL组成URL:协议://主机:端口/路径?查询#片段(哈希值)scheme://host:port/path?query#fragment $route和$router区别 $route拿到的是处于活跃的路由 $router就是最开始new的router对象 所有组件都继承自vue类的原型 所以在vue的原型上绑任何函数、属性，任何组件都可以使用12Vue.prototype.$methods = methods()Vue.prototype.state = 'state' 导航守卫最主要的作用就是监听导航从哪跳到哪 应用：使用全局路由守卫 修改页面标题next()是一下步的意思，如果不调用后续都不执行了meta 是元数据 是描述数据的数据 补充：全局守卫路由独享守卫组件内守卫 keep-alive组件使用 作用就是进入/离开这个组件的时候不要频繁的创建/销毁这个组件 如果组件被keep-alive包裹的话组件内就可以使用 activated()/deactivated() 应用 跳转回之前页面 组件不重新刷新使用了beforeRouteLeave记录this.$route.path属性 keep-alive两个属性 include exclude 应用：tabbar实现 封装组件的设计思路设置插槽具名插槽是如何替换的 123&lt;div slot=&quot;name&quot;&gt;&lt;/div&gt;替换&lt;slot name=&quot;name&quot;&gt;&lt;/slot&gt; 全局样式设置在style标签内用@import引用flex:1 均等分 tabbar路由跳转——页面目录结构文件命名views——视图profile——个人、档案 封装tabbar的字体颜色——动态绑定样式如果逻辑过于复杂，可以提取到计算属性中 回顾","link":"/2023/04/12/%E8%B7%AF%E7%94%B1/"},{"title":"预解析","text":"详见下文 预解析 变态机制 走后门、关系户有个性化人情味儿在里面 ES5的特色 预解析会解析什么？ var、function 案例——var 1234567console.log(a)var a = 10解析过程var aconsole.log(a) // undefineda = 10 代码执行过程、解析过程 1、提前解析关键字var、function2、提前赋值情况1：对var是仅提前定义没有赋值情况2：对function整体变量提升、并且赋值3、预解析结束后，浏览器再逐行解读代码 案例——function 1234console.log(fn)function fn (){ console.log('123')} 案例 123456789101112131415console.log(b);var b = 100;function b(){ console.log(999)};//解析过程 //预解析var b;function b(){ console.log(999)};//逐行解析console.log(b); //[Function: b]b = 100; 解析原则预解析过程中，当变量和函数同名时：只留下函数的值，不管谁前谁后，所以函数优先级更高； 案例——测试变量和函数的优先级 1234567891011121314console.log(b);function b(){ console.log(999)};var b = 100;//解析过程 //预解析function b(){ console.log(999)};var b;//逐行解析console.log(b); //[Function: b]b = 100; 123456789101112131415161718192021222324252627//扩展练习一console.log(a,b,c,d,e);var a = 10;var b;c = 100;function d(){ console.log('d')};var e = function(){ console.log('e')};//解析过程 //预解析var a;var b;function d(){ console.log('d')};var e;//逐行解析console.log(a,b,c,d,e); //a = undefined; b = undefined; c-报错; d=function(){}; e = undefined; a = 10;c = 100;e = function(){ console.log('e')}; 12345678910111213141516171819202122//扩展练习二console.log(a);var a = 1;function a(){console.log(2)};console.log(a);var a = 3;console.log(a);function a(){console.log(4)};console.log(a);//解析过程 //预解析var a;function a(){console.log(2)};function a(){console.log(4)};//逐行解析console.log(a); //function a(){console.log(4)};a = 1;console.log(a); //1a = 3;console.log(a); //3console.log(a); //3 预解析经典面试题 12345678910111213141516171819202122232425function fun ( n ) { console.log( n ); var n = 456; console.log( n );}var n = 123;fun( n );答：123 456 //解析过程 //预解析 var n; function fun(){}; n = 123 //全局变量 fun(n) ////当执行fun(n)，会执行函数体里的内容，此时fun函数会形成一个新的私有作用域 //fun()内部解析过程 //如果有形参，先给形参赋值 var n = 123; //进行私有作用域中的预解析； var n; //私有作用域中的代码从上到下执行 console.log( n ); //123 n = 456; console.log( n ); //456","link":"/2023/03/23/%E9%A2%84%E8%A7%A3%E6%9E%90/"},{"title":"Vue3笔记","text":"详见下文 Vue3新特性Vue3项目的创建安装Vue-cli脚手架构建工具Vue-cli 提供一个官方命令行工具，可用于快速搭建大型单页应用。 输入命令 1cnpm install -g @Vue/cli 查看版本，要求Vue-cli版本在4.5以上，可以创建Vue3项目 创建Vue3项目Vue create 项目名称 手动安装 启动项目 createApp在 Vue 3 中，改变全局 Vue 行为的 API 现在被移动到了由新的 createApp 方法所创建的应用实例上。 12import { createApp } from 'Vue'const app = createApp({}) 调用 createApp 返回一个应用实例。该实例提供了一个应用上下文。应用实例挂载的整个组件树共享相同的上下文，该上下文提供了之前在 Vue 2.x 中“全局”的配置。 另外，由于 createApp 方法返回应用实例本身，因此可以在其后链式调用其它方法 Vue3.0中使用createApp 来创建Vue实例 1234import { createApp } from 'Vue'import App from './App.Vue'const app = createApp(App);app.mount('#app'); main.js 下加载router、Vuex 123456789101112import { createApp } from 'Vue'import App from './App.Vue'import router from './router'import store from './store'const app = createApp(App);app.use(store)app.use(router)app.mount('#app');合并之后的代码：createApp(App).use(store).use(router).mount('#app') setup函数1、简介setup函数是Vue3中专门为组件提供的新属性。 2、执行时机创建组件实例，然后初始化props，紧接着就调用setup函数，会在beforeCreate钩子之前被调用。 3、模板中使用如果setup返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文。 4、如何使用123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; {{name}} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive } from &quot;Vue&quot;export default { props:{ item:String } //setup函数会在beforeCreate之后，created之前执行 setup相当于是预设配置 //setup函数的第一个形参，接收props数据,通过props.item获取 setup(props){ //创建响应式数据对象 const state = reactive({ name:'abc' }) //setup函数中将响应式数据对象return出去供template使用 return state }}&lt;/script&gt; 注意：在setup()函数中无法访问到this reactive函数1、简介reactive()函数接收一个普通对象，返回一个响应式的数据对象 2、基本语法12345按需导入reactive函数import { reactive} from &quot;Vue&quot;创建响应式数据对象const state = reactive({ id:1 }) 3、定义响应式数据供template使用123456789101112131415161718191)按需导入reactive函数import { reactive} from &quot;Vue&quot;2)在setup()函数中调用reactive()函数，创建响应式数据对象setup(){ //创建响应式数据对象 const state = reactive({ name:'abc' }) //setup函数中将响应式数据对象return出去供template使用 return state}3)在template中访问响应式数据&lt;template&gt; &lt;div&gt; {{name}} &lt;/div&gt;&lt;/template&gt; ref的使用1、简介ref()函数用来根据给定的值创建一个响应式的数据对象，ref()函数调用的返回值是一个对象，这个对象上只包含一个value属性 常用在操作dom 2、基本语法1234567891011121314151)按需导入ref函数import { ref } from &quot;Vue&quot;2)在setup()函数中调用ref()函数，创建响应式数据对象setup(){ var c = ref(10); //初始化值为10 return {c}}3)在template中访问响应式数据&lt;template&gt; &lt;div&gt; {{c}} &lt;/div&gt;&lt;/template&gt; 3、如何使用1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p&gt;{{c}}&lt;/p&gt; &lt;button @click=&quot;change()&quot;&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { ref } from &quot;Vue&quot;export default { setup(){ var c = ref(10); //初始化值为10 const change=()=&gt;{ //方法的定义 c.value+=1; //想改变值或获取值 必须.value } return { c, change }; }}&lt;/script&gt; 在reactive()函数中的使用 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p&gt;{{a}}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { ref,reactive,onMounted } from &quot;Vue&quot;export default { setup(){ const state = reactive({ a:ref(99) }) onMounted(()=&gt;{ //生命周期-挂载完成 setInterval(function(){ state.a +=10 },1000) }) return state; }}&lt;/script&gt; 4、ref()和reactive的不同 reactive的用法与ref的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是ref用于基本数据类型，而reactive是用于复杂数据类型 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;p&gt;{{d}}&lt;/p&gt; &lt;button @click=&quot;change()&quot;&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive } from &quot;Vue&quot;;export default { setup() { let d = reactive(10); function change() { console.log(d); d+=1; //页面不会同步渲染 } return { d,change }; },};&lt;/script&gt;运行发现，基本数据传递给reactive，reactive并不会将它包装成porxy对象，并且当数据变化时，界面不会同步渲染变化 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;p&gt;{{d.id}}&lt;/p&gt; &lt;button @click=&quot;change()&quot;&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive } from &quot;Vue&quot;;export default { setup() { let d = reactive({id:10}); //对象可同步渲染 function change() { d.id+=1; } return { d,change }; },};&lt;/script&gt; toRefs的使用1、简介toRefs()函数可以将reactive()创建出来的响应式对象，转换为普通对象，只不过这个对象上的每个属性节点，都是ref()类型的响应式数据 注意！！！使用场景比如：当想要从一个组合逻辑函数中返回响应式对象时，用 toRefs 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 … 操作符）返回的对象，并不会丢失响应性 1.多个属性再一个对象中2.多个方法在一个对象中 2、基本语法1234567891011121314151617181920212223241)按需导入toRefs函数import { reactive ,toRefs } from &quot;Vue&quot;;2)...toRefs(state)创建响应式数据对象setup(){ let state = reactive({ id:10 }); let methods = { fun1 (){} fun2 (){} }); return { ...toRefs(state), ...methods //方法不用toRefs,方法处理的就是包裹在reactive中的响应式数据，环环相扣的 };}3)在template中访问响应式数据&lt;template&gt; &lt;div&gt; &lt;p&gt;{{id}}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 3、如何使用1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;p&gt;{{id}}&lt;/p&gt; &lt;button @click=&quot;change()&quot;&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive ,toRefs } from &quot;Vue&quot;;export default { setup() { let state = reactive({id:10}); function change() { state.id+=1; console.log(state.id); } return { //如果只返回state，可以return state但还有其它对象 //...state , 单向数据绑定,不支持双向数据渲染 //ES6中的扩展运算符和解构会把双向数据渲染的特性取消,除非用到toRefs来处理 //toRefs函数可以将reactive创建出来的对象都转化为ref形式的响应式数据 ...toRefs(state), //转成ref形式的响应式数据 change //事件处理函数 } },};&lt;/script&gt; computed计算属性的使用1、简介computed()用来创建计算属性，computed()函数的返回值是一个 ref 的实例 2、基本语法1234567891011121314151617181920211)按需导入computed()import { reactive ,toRefs ,computed} from &quot;Vue&quot;;2)在setup()函数中调用computed()函数setup(){ let state = reactive({ id:10, n1:computed(()=&gt;state.id+1) //计算属性的方式，可以直接写在这里 n2:computed(function(){ state.id+2 }) });}3)在template中访问响应式数据&lt;template&gt; &lt;div&gt; &lt;p&gt;{{n1}}&lt;/p&gt; &lt;p&gt;{{n2}}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 3、如何使用1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;p&gt;{{n}}&lt;/p&gt; &lt;button @click=&quot;change()&quot;&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive ,toRefs ,computed} from &quot;Vue&quot;;export default { setup() { let state = reactive({ id:10, n:computed(()=&gt;state.id+10) //计算属性的方式 }); function change() { state.id+=1; console.log(state.id); } return { ...toRefs(state), change } },};&lt;/script&gt; watch的使用1、简介watch() 函数用来监视某些数据项的变化，从而触发某些特定的操作 不要添加太多监听，影响性能，本来vue就是响应式数据 面包屑用的还挺多的优先使用：响应式&gt;计算属性&gt;监听 监听是监听某个值计算属性是处理这个属性的任何一个值变化都会触发变化 2、基本语法123456789101)按需导入watch()import { reactive ,toRefs ,watch} from &quot;Vue&quot;;2)在setup()函数中调用watch()函数setup() { let state = reactive({ id:10, }); watch(() =&gt; console.log(state.id)) }, 3、如何使用12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;p&gt;{{id}}&lt;/p&gt; &lt;p&gt;{{type}}&lt;/p&gt; &lt;button @click=&quot;change()&quot;&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive ,toRefs ,watch} from &quot;Vue&quot;;export default { setup() { let state = reactive({ id:10, type:'偶数' }); //监听state.id的值的变化 watch(() =&gt; state.id, (cur, old) =&gt; { if(cur % 2 == 0 ){ state.type = '偶数' }else { state.type = '奇数' } }) function change() { state.id+=1; } return { ...toRefs(state), change } },};&lt;/script&gt; 4、清除监听1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;p&gt;{{id}}&lt;/p&gt; &lt;p&gt;{{type}}&lt;/p&gt; &lt;button @click=&quot;change()&quot;&gt;click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive ,toRefs ,watch} from &quot;Vue&quot;;export default { setup() { let state = reactive({ id:10, type:'偶数' }); // 创建监听，并得到停止函数 const stop = watch(() =&gt; state.id, (cur, old) =&gt; { if(cur % 2 == 0 ){ state.type = '偶数' }else { state.type = '奇数' } }) function change() { state.id+=1; if(state.id == 15){ // 调用停止函数，清除对应的监听 stop() } } return { ...toRefs(state), change } },};&lt;/script&gt; 生命周期钩子函数1、基本语法12345678910111213141516171)新版的生命周期函数，可以按需导入到组件中，且只能在 setup() 函数中使用import { onMounted, onUpdated, onUnmounted} from &quot;Vue&quot;;2)在setup()函数中调用computed()函数setup(){ onMounted(() =&gt; { console.log('mounted!') }) onUpdated(() =&gt; { console.log('updated!') }) onUnmounted(() =&gt; { console.log('unmounted!') })}常用在轮播 2、新旧对比123456789beforeCreate -&gt; use setup()created -&gt; use setup()beforeMount -&gt; onBeforeMountmounted -&gt; onMountedbeforeUpdate -&gt; onBeforeUpdateupdated -&gt; onUpdatedbeforeDestroy -&gt; onBeforeUnmountdestroyed -&gt; onUnmountederrorCaptured -&gt; onErrorCaptured 3、如何使用1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt; &lt;p&gt;{{num}}&lt;/p&gt; &lt;p&gt;{{type}}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;import { reactive ,toRefs ,onMounted, onUpdated, onUnmounted} from &quot;Vue&quot;;export default { setup() { var timer = null; let state = reactive({ num:1, type:'奇数' }); const autoPlay=()=&gt;{ state.num++; if(state.num == 5){ state.num = 0; } } const play=()=&gt;{ timer = setInterval(autoPlay,1000) } onMounted(()=&gt;{ //挂载完成 play(); }) onUpdated(()=&gt;{ if(state.num % 2 == 0 ){ state.type = '偶数' }else { state.type = '奇数' } }) onUnmounted(()=&gt;{ //销毁 clearInterval(timer); }) return { ...toRefs(state) } },};&lt;/script&gt; 父子数据传递3种方式1、:item=’item’ 和 props:{}2、provide和inject 不是异步的provide可以给多个子组件传数据用inject接收即可 不用每个组件都写:了以上两个都是在父请求完数据再传到子3、Suspense 异步加载组件要在setup 处加 async await 获取异步数据 直接在子请求数据 provide和inject1、简介provide()和 inject()可以实现嵌套组件之间的数据传递。这两个函数只能在 setup()函数中使用。父级组件中使用 provide()函数向下传递数据；子级组件中使用 inject()获取上层传递过来的数据。 2、基本语法1234567891011121314151617181920212223父组件：1)按需导入provide()import { reactive ,toRefs ,provide} from &quot;Vue&quot;;2)在setup()函数中调用provide()函数setup() { // 父级组件通过 provide 函数向子级组件共享数据 //provide('要共享的数据名称', 被共享的数据) provide('globalColor', 'red') },子组件：1)按需导入provide()import { reactive,toRefs,inject} from &quot;Vue&quot;2)在setup()函数中调用inject()函数 setup(props){ const state = reactive({ //调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 color : inject(&quot;globalColor&quot;) }) return state } 3、如何使用父组件： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;根组件&lt;/h1&gt; &lt;Demo1 /&gt; &lt;Demo2 /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Demo1 from '@/components/demo1'import Demo2 from '@/components/demo2'// 1. 按需导入 provideimport { reactive ,toRefs ,provide} from &quot;Vue&quot;;export default { setup() { // 父级组件通过 provide 函数向子级组件共享数据 //provide('要共享的数据名称', 被共享的数据) provide('globalColor', 'red') }, components: { Demo1, Demo2 }}&lt;/script&gt; 子组件1： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; {{name}}----{{color}} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive,computed, provide,inject,toRefs} from &quot;Vue&quot;export default { setup(props){ //创建响应式数据对象 const state = reactive({ name:'demo1', //调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 color : inject(&quot;globalColor&quot;) }) return state }}&lt;/script&gt; 子组件2： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; {{name}}----{{color}} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { reactive,computed, provide,inject,toRefs} from &quot;Vue&quot;export default { setup(props){ //创建响应式数据对象 const state = reactive({ name:'demo2', //调用 inject 函数时，通过指定的数据名称，获取到父级共享的数据 color : inject(&quot;globalColor&quot;) }) return state }}&lt;/script&gt; Suspense 异步组件1、什么是Suspense组件Suspense组件用于在等待某个异步组件解析时显示后备内容。 2、何时使用它1、在页面加载之前显示加载动画 2、显示占位符内容 3、处理延迟加载的图像 3、如何使用1234567插槽包裹异步组件&lt;Suspense&gt; &lt;template #default&gt; &lt;Async/&gt; &lt;/template&gt;&lt;/Suspense&gt;具名插槽的缩写是在 Vue2.6.0 新增，跟 v-on 和 v-bind 一样，v-slot 也有缩写， 替换为字符 #。例如 v-slot:header 可以被重写为 #header 123456插槽包裹渲染异步组件之前的内容&lt;Suspense&gt; &lt;template #fallback&gt; &lt;h1&gt;Loading...&lt;/h1&gt; &lt;/template&gt;&lt;/Suspense&gt; 4、如何运用父组件中定义 12345678&lt;Suspense&gt; &lt;template #default&gt; &lt;List /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div&gt;loading......&lt;/div&gt; &lt;/template&gt;&lt;/Suspense&gt; List子组件中的处理 12345678910111213import {getPage} from '@/api/http'export default { async setup(){ const res = await getPage(); const state = reactive({ items : res.data.data }); return { ...toRefs(state) }; }} 什么时候用路由守卫？什么时候用生命周期钩子1、路由是其中一个参数变化了路由就要重新加载，影响效率2、生命周期钩子是在组件的生命周期，只要路由没变，就不会重新加载一遍 Vue Router 4现在我们安装 Vue-router 版本的时候，默认还是安装的 3.x 版本的，由于 Vue3 的更新发生很大的变化，所以为了兼容处理，Vue-router 也将发布最新版 4.x 版本了。 数据处理方式例子 底部导航静态数据1、在页面写死2、在setup内定义数据3、发送请求获取数据4、页面引入单独数据文件 路由数据信息处理1、直接在路由里写完整数据，不需要外部引入2、路由数据提到外部，内部再遍历动态引入数据 动态路由的几种方式：1、默认写死2、通过后端返回的角色动态对路由进行过滤 1、创建方式利用createRouter 用来创建router对象 12345import { createRouter } from 'Vue-router'const router = createRouter({ routes}) 2、路由模式router 3的用法 1const router = new VueRouter({mode: 'hash' / 'history'}) router 4的用法 createWebHashHistory路由模式路径带#号 createWebHashHistory (hash) createWebHistory路由模式路径不带#号() createWebHistory(history) 1234567import { createRouter,createWebHashHistory } from 'Vue-router'const router = createRouter({ history: createWebHashHistory(), routes}) 3、组件中的使用因为setup中不能访 this,所以提供两个api来获取 router 和 route ， useRouter() 和 useRoute() 但是 除了setup，比如在computed、methods中可以使用this.$router、this.$route 1234567891011121314151617import { useRouter,useRoute } from &quot;vue-router&quot; export default({ setup(){ const router = useRouter(); //router是全局路由的实例,是VueRouter的实例 const route = useRoute(); //route对象表示当前的路由信息，包含了当前 URL 解析得到的信息 const goBack = () =&gt; { router.push('/home'); } onMounted(()=&gt;{ //生命周期-挂载完成 //获取路由参数 console.log(route.params.id); }) return{ goBack } } }) 4、路由守卫路由守卫分类1 、全局前置守卫 beforeEach12345678910111213全局守卫router.beforeEach((to, from, next) =&gt;{to: Route：导航到的目标Route对象from: Route：当前路线被导航离开next: Function：必须调用此函数来解析钩子 console.log(to); if (!sessionStorage.getItem(&quot;username&quot;)) { //如果没有签到或打卡 if (to.path !== '/home') { next('/home') } }; next()}) 2 、全局后置守卫 afterEach123router.afterEach((to, from) =&gt;{ // ...}) 3、 全局解析守卫 beforeResolve和router.beforeEach类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用 4 、路由专享守卫 beforeEnter它们只有在 从一个不同的 路由导航 进入时，才会被触发。 123456789101112131415const routes = [ { path: '/', redirect: '/home' }, { path: '/home', component: () =&gt; import( '../views/Home'), beforeEnter: (to, from, next) =&gt; { //路由独享的守卫 console.log(to); next() } }}] 5 、组件内守卫 beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave123456789101112131415161718192021222324252627&lt;script&gt;import { reactive, toRefs } from &quot;Vue&quot;export default { setup(props, context) { const state = reactive({}); return { ...toRefs(state), }; }, beforeRouteEnter (to, from, next) { //组件内守卫 // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 }, beforeRouteUpdate (to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` }, //离开守卫通常用来禁止用户在还未保存修改前突然离开。导航该可以通过next(false)来取消 beforeRouteLeave (to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` }}&lt;/script&gt; 6、导航解析流程1） 导航被触发 2） 在失活的组件里调用离开守卫beforeRouteLeave(to,from,next) 3）调用全局前置守卫 beforeEach(to,from,next) 4） 在复用的组件里调用beoreRouteUpdate(to,from,next) 5） 在路由配置里调用路由独享的守卫beforeEnter() 6）解析异步路由组件 7）在被激活的组件里调用beforeRouteEnter(to,from,next) 8）调用全局解析组件beforeResolve 9） 导航被确认 10） 调用全局后置守卫afterEach() 11）触发DOM更新 12） 用创建好的实例调用beforeRouteEnter守卫中传递给next的回调函数 Vuex41、创建方式state定义的初始化数据 getters相当于计算属性 actions和mutations的区别 actions相当于产品 用dispatch触发mutations相当于开发 用commit触发用户点击页面进行交互先在actions过滤一下需求再去commit触发mutations 1234567891011121314151617181920212223242526272829303132333435创建 store 容器实例import { createStore } from 'Vuex'const state = { isNavShow:true};var getters = { showNav(state){ return state.isNavShow }}const actions={ SHOWNAV({commit}){ commit('SHOWNAV'); }, HIDENAV({commit}){ commit('HIDENAV'); }};const mutations = { SHOWNAV(state){ state.isNavShow=true; }, HIDENAV(state){ state.isNavShow=false; },};const store = createStore({ state, getters, actions, mutations})//导出store对象export default store; 2、组件中的使用123456789101112131415import { useStore } from &quot;Vuex&quot;; //导入Vuexexport default { props:{ name:String },setup(props, context) { let store = useStore(); //定义store const state = reactive({}); return { ...toRefs(state), store }; },} 3、State 和 Getters 的用法1234567891011121314151617import { useStore } from &quot;Vuex&quot;; //导入Vuexexport default { props:{ name:String },setup(props, context) { let store = useStore(); //定义store const state = reactive({ showNav:computed(()=&gt;store.getters.showNav) }); return { ...toRefs(state), store }; },} 4、Mutations 和 Actions 的用法1234567891011121314151617181920import { useStore } from &quot;Vuex&quot;; //导入Vuexexport default { props:{ name:String },setup(props, context) { let store = useStore(); //定义store const state = reactive({}); onUnmounted(()=&gt;{ //生命周期-销毁 store.dispatch('SHOWNAV'); //触发actions //store.commit('SHOWNAV'), // 触发mutations }) onMounted(()=&gt;{ //生命周期-挂载完 store.dispatch('HIDENAV'); }) return { ...toRefs(state), store }}","link":"/2023/03/24/VUE3%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Vuex","slug":"Vuex","link":"/tags/Vuex/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"promise","slug":"promise","link":"/tags/promise/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"Vue CLI","slug":"Vue-CLI","link":"/tags/Vue-CLI/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"模块化","slug":"模块化","link":"/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"感悟","slug":"感悟","link":"/tags/%E6%84%9F%E6%82%9F/"},{"name":"思考","slug":"思考","link":"/tags/%E6%80%9D%E8%80%83/"},{"name":"深拷贝和浅拷贝","slug":"深拷贝和浅拷贝","link":"/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"VueRouter","slug":"VueRouter","link":"/tags/VueRouter/"},{"name":"Vue3","slug":"Vue3","link":"/tags/Vue3/"}],"categories":[{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"}]}