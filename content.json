{"pages":[{"title":"About The Blog","text":"一个普通IT人的博客站 思考、记录、分享 欢迎访问我的博客，交流或者有问题请留言 或QQ联系。我的QQ：1144536063","link":"/about/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"About The Plan","text":"不以物喜，不以己悲。——2021.08.13 生活安排早6点40起床 工作期间按照小时安排工作，小时间隔站立适当调整 锻炼30min 晚11:00睡上床：读书30min 晚11:30睡觉 近期计划 开始时间 结束时间 内容 情况 2022.07.09 精品 2022.07.09 配件第一部分 2022.07.09 Java基础 长期计划 开始时间 结束时间 内容 情况 2022.07.09 Java基础 SpringBoot Dubbo+zookeeper SpringSecurity SpringCloud DevOps：docker+k8s+jenkins ElasticSearch SQL进阶：索引、视图 工作流","link":"/plan/index.html"},{"title":"","text":"sup { position: relative; top: -0.4em; vertical-align: baseline; } sub { position: relative; top: 0.4em; vertical-align: baseline; } a:link {text-decoration:none;} a:visited {text-decoration:none;} @media screen and (min-device-pixel-ratio:0), (-webkit-min-device-pixel-ratio:0), (min--moz-device-pixel-ratio: 0) { .view { font-size:10em; transform:scale(0.1); -moz-transform:scale(0.1); -webkit-transform:scale(0.1); -moz-transform-origin:top left; -webkit-transform-origin:top left; } } .layer { }.ie { font-size: 1pt; } .ie body { font-size: 12em; } .stl_01 { position: absolute; white-space: nowrap; } .stl_02 { height: 70.08334em; font-size: 1em; margin: 0em; line-height: 0.0em; display: block; border-style: none; width: 49.58333em; } .stl_03 { position: relative; } .stl_04 { position: absolute; left: 0em; top: 0em; } .stl_05 { position: relative; width: 49.58333em; } .stl_06 { height: 7.008333em; } .ie .stl_06 { height: 70.08334em; } @font-face { font-family:\"MMPWKS+MicrosoftYaHei-Bold\"; src:url(\"3371fe3b-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_07 { font-size: 1.829167em; font-family: \"MMPWKS+MicrosoftYaHei-Bold\", \"Times New Roman\"; color: #44546B; } .stl_08 { line-height: 1.041992em; } .stl_09 { letter-spacing: 0.0004em; } .ie .stl_09 { letter-spacing: 0.0125px; } @font-face { font-family:\"DIKHKL+MicrosoftYaHei\"; src:url(\"1b0cfbf9-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_10 { font-size: 1em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #525252; } .stl_11 { letter-spacing: -0.0036em; } .ie .stl_11 { letter-spacing: -0.0582px; } @font-face { font-family:\"AJAHDD+MicrosoftYaHeiLight\"; src:url(\"ec0f8afa-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_12 { font-size: 0.870833em; font-family: \"AJAHDD+MicrosoftYaHeiLight\", \"Times New Roman\"; color: #525252; } .stl_13 { letter-spacing: 0em; } .ie .stl_13 { letter-spacing: 0px; } .stl_14 { letter-spacing: -0.2519em; } .ie .stl_14 { letter-spacing: -3.5103px; } .stl_15 { letter-spacing: -1.007em; } .ie .stl_15 { letter-spacing: -14.0303px; } .stl_16 { letter-spacing: -0.046em; } .ie .stl_16 { letter-spacing: -0.6408px; } .stl_17 { letter-spacing: -0.0905em; } .ie .stl_17 { letter-spacing: -1.2611px; } .stl_18 { letter-spacing: -0.1571em; } .ie .stl_18 { letter-spacing: -2.1883px; } .stl_19 { font-size: 1.079167em; font-family: \"MMPWKS+MicrosoftYaHei-Bold\", \"Times New Roman\"; color: #FFFFFF; } .stl_20 { letter-spacing: -0.0003em; } .ie .stl_20 { letter-spacing: -0.0054px; } .stl_21 { font-size: 1em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #585858; } .stl_22 { letter-spacing: 0.0005em; } .ie .stl_22 { letter-spacing: 0.0083px; } .stl_23 { font-size: 0.870833em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #585858; } .stl_24 { letter-spacing: -0.0004em; } .ie .stl_24 { letter-spacing: -0.0062px; } .stl_25 { letter-spacing: 0.0018em; } .ie .stl_25 { letter-spacing: 0.0255px; } .stl_26 { letter-spacing: 0.001em; } .ie .stl_26 { letter-spacing: 0.014px; } .stl_27 { letter-spacing: 0.0047em; } .ie .stl_27 { letter-spacing: 0.0662px; } .stl_28 { letter-spacing: 0.0029em; } .ie .stl_28 { letter-spacing: 0.041px; } .stl_29 { letter-spacing: 0.0036em; } .ie .stl_29 { letter-spacing: 0.0504px; } .stl_30 { letter-spacing: -0.0008em; } .ie .stl_30 { letter-spacing: -0.0115px; } .stl_31 { letter-spacing: 0.0011em; } .ie .stl_31 { letter-spacing: 0.0147px; } .stl_32 { letter-spacing: -0.0075em; } .ie .stl_32 { letter-spacing: -0.1049px; } .stl_33 { letter-spacing: 0.0022em; } .ie .stl_33 { letter-spacing: 0.0307px; } .stl_34 { letter-spacing: -0.0051em; } .ie .stl_34 { letter-spacing: -0.0705px; } .stl_35 { letter-spacing: 0.0044em; } .ie .stl_35 { letter-spacing: 0.0609px; } .stl_36 { font-size: 0.870833em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #595959; } .stl_37 { letter-spacing: 0.0038em; } .ie .stl_37 { letter-spacing: 0.0524px; }","link":"/resume/style.css"},{"title":"文章标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"promise和generator语法糖-async await","text":"有了 async-await、promise 还有必要学习吗? async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性。简单来说：async-await 是建立在 promise机制之上的，并不能取代其地位。 async1234async function timeout() { return 'hello world'} timeout(); //为什么没有执行'hello world' 1234async function timeout() { return 'hello world'}console.log(timeout()); //Promise {&lt;resolved&gt;: &quot;hello world&quot;} async 函数返回的是一个promise 对象，如果要获取到promise 返回值，应该用then 方法 12345678async function fn(){ return 100;}console.log(fn()); //Promise {&lt;resolved&gt;: 100}let f = fn();f.then(function(d){ console.log(d) //100}) awaitawait操作符用于等待一个Promise对象，它只能在异步函数async function内部使用。返回值：返回promise对象的处理结果，如果等待的不是promise对象，则返回该值本身如果一个promise被传递给一个await操作符，await将等待promise正常处理完成并返回其处理结果 12345678910function f2(){ console.log(4)}async function f(){ await f2(); console.log(2) }f();console.log(3);// 4 3 2 正常情况下，await命令后面是一个promise对象，它也可以是其它值，如字符串，布尔值，数值以及普通函数。 123456789console.log(2)async function fn(){ console.log(3) await 100; console.log(1)}fn()console.log(4)// 2 3 4 1 await命令后面是一个promise对象 12345678910111213function p(){ return new Promise(resolve=&gt;{ resolve(); console.log(1) });};async function fn(){ console.log(2) await p(); console.log(3)}fn()// 2 1 3","link":"/2022/08/13/promise%E5%92%8Cgenerator%E8%AF%AD%E6%B3%95%E7%B3%96-async-await/"},{"title":"史上最全hexo博客搭建步骤详解","text":"我的第一篇博客，先给hexo~ 前言本篇讲解主要参考codesheep的关于hexo搭建的视频，结合自己踩的一些坑，综合各路大神的指南而成，如果你在实践本篇博文的过程中有任何问题，欢迎和我一起交流~ 搭建博客的目的： 明确我们的目标才不会让你半途而废 社招、校招加分项 追求极客范儿 挑战自己，我很棒 总览一下我们搭建hexo博客的步骤： 搭建node.js环境 安装加速包cnpm hexo安装 使用hexo搭建博客 新建第一篇博文 把博客部署到github 博客换肤以上就是博客搭建过程概览 下面我们按照上面的步骤逐一实现，你也可以拥有属于自己的博客哟~操作的过程中先不用问太多为什么，照做就行了 1、搭建node.js环境1.1 下载node.jshexo是node.js生成的，需要node.js环境 nodejs官网：nodejs.org nodejs官网图 建议：不要下载最新的node版本，我下载的12版本的 12版本list图 自动安装包格式.pkg 傻瓜安装，一直点同意就好了 安装的结果实际上安装了两个文件一个是node.js另一个是npm包管理器,这是搭建hexo必备 1.2 查看安装的node与npm版本 打开终端 12查看node版本：输入 node -v查看npm版本：输入 npm -v 这里codesheep是在root用户下操作的，但是到后面我使用编辑器操作文件会有点麻烦，总是需要root权限，所以这个因人而异吧 啰嗦一句~每次我们安装或者操作什么都要及时检查这个操作是否成功，程序员基操吧 2、安装加速包cnpm因为国内镜像源的安装速度慢，所以我们安装一个淘宝镜像源，为一会安装hexo速度快 2.1利用npm安装cnpm1输入 npm install -g cnpm --registry=https://registry.npm.taobao.org 2.2查看cnpm版本1输入 cnpm -v cnpm版本截图 3、hexo安装3.1用cnpm安装hexo1输入 cnpm install -g hexo-cli 3.2查看hexo版本1输入 hexo -v 图 4、使用hexo搭建博客4.1建一个空的文件夹blog这个文件夹是存放我们博客所有内容的，那么在建文件夹前先看一下我们当前的位置，方便后续寻找我们的blog文件夹在哪 1查看当前位置：输入 pwd 图 123新建blog文件夹：输入 mkdir blog进入blog：输入 cd blog查看当前位置：输入 pwd 此时我们的路径是/blog结尾，接下来是在这个blog文件初始化我们的hexo 4.2 初始化hexo1初始化hexo：输入 init hexo 此时可以看到克隆到了hexo文件和默认landscape主题 进入blog文件查看初始化都自动生成了哪些文件，后续我们写博客都基于这里面的文件，瞅一眼有啥就行 4.3启动博客1启动hexo:输入 hexo s 此时终端会出现 http://localhost:4000/ 表示我们再本地已经启动成功博客，点这个链接进来看看我们搭建的博客以上我们的博客就搭建完成了，是不是没那么难~ 博客有了我们开始写文章吧~5、新建第一篇博文5.1 创建博文1新建博文：输入 hexo n &quot;你的博文标题&quot; 可以看到我们的博文被创建到source/_posts目录下了，并且是.md格式的，到编辑器(我使用的是vscode)里面打开这个文件，开始写你的第一篇博文吧~ 5.2 查看你完成的第一篇博文写完之后，再次启动一下我们的博客，在本地查看我们新写的一篇博文 看下当前你的位置 1输入 pwd 我们后面的操作依然要回到blog文件下面 接着输入 hexo clean 清理一下 1输入 hexo g 生成一下 先不要问为啥，你以后会知道，照做 1输入 hexo s 启动 刷新刚打开的网址，可以看到我们刚写的博文已经出现了 6、把博客部署到github我们想要一个远端地址可以查看我们的博客，推荐github部署方式，免费万岁！ 6.1 创建github仓库网址：github.com 没有账号的自己注册，不赘述啦，毕竟我们的主题是hexo 登录进来 页面右上角，头像的左边👈🏻有个➕号，➕号下拉框里点New repository新建一个仓库 点进来填写Repository name 命名规范：你的用户名.github.io 你的用户名就是旁边的Owner里面写的 比如我的用户名：inie96 那么就是 inie96.github.io 用户部署个人博客的github仓库的命名必须是这个 点 Create repository 创建仓库完成 6.2 安装git部署插件终端进入到blog文件下 1安装git：输入 cnpm install --save hexo-deployer-git 6.3 设置blog文件下的_config.yml文件来编辑器里，找到blog文件下的_config.yml文件 最下面有个# Deployment 找到他 在他下面配置上这三行 1234type: gitrepo: git@github.com:inie96/inie96.github.io.git（这里配置成我们刚创建仓库的ssh地址，注意是ssh）branch: master 图 最终长这样 6.4 向github部署博客终端回到blog 输入 hexo d 接着会提示你输入github账号密码 部署完成后去刷新刚创建的github仓库，此时已经有文件进来了，就是部署成功了 把仓库名拿出来访问inie96.github.io就可以在远端查看博客了~ 以上我们的博客远端部署完成 7、博客换肤7.1 挑选皮肤网址：https://hexo.io/themes/ 7.2 进入喜欢的皮肤的仓库我选的是icarus 仓库地址：https://github.com/ppoffice/hexo-theme-icarus 7.3 下载主题回到终端blog下面 克隆/下载主题：输入 git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus themes/icarus 是我们要下载到的文件位置 此时在文件夹中打开这个路径就可以看到我们下载的主题文件 7.4 给我的博客配置icarus主题修改刚刚我们也改过的blog文件下的_config.yml文件 这个文件还蛮重要 1修改 theme: icarus 修改成themes下的icarus文件名 图 此时我们再次 123hexo cleanhexo ghexo s 在本地查看一下更换的主题 打开 http://localhost:4000/ 查看没有问题，推送到远端 1输入 hexo d 在远端地址查看更改后的皮肤，换肤完成 总结 安装node 安装cnpm 安装hexo 初始化hexo：init hexo 创建hexo博文：hexo n 部署hexo到github 创建github仓库 安装git 配置文件 hexo d 博客换肤 下载主题 git clone 配置文件 hexo d hexo四件套 1234hexo cleanhexo ghexo shexo d 欢迎观看~ 完结撒花~","link":"/2022/05/21/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3/"},{"title":"异步编程解决方案-Promise","text":"一篇搞定Promise~ 定义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓 Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。解决 JS中多个异步回调难以维护和控制的问题 Promise 对象有以下两个特点 对象的状态不受外界影响。 Promise 对象代表一个异步操作，有三种状态： pending （进行中）、 fulfilled （已成功）和 rejected （已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承 诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。基本用法Promise 对象是一个构造函数，用来生成 Promise 实例。123456789101112var p = new Promise(function(resolve,reject){ if(true){ //请求成功 resolve('ok') }else { reject('error') }});p.then(function(res){ console.log(res)},function(res){ console.log(res)}) 解释Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。解决回调陷阱12345678910111213141516171819202122let p = new Promise(function(resolve, reject){ if (true){ resolve(&quot;成功&quot;); } else { reject(&quot;失败&quot;); }})p.then(function(v){ return new Promise(function(resolve, reject){ if (true){ resolve(&quot;成功&quot;); } else { reject(&quot;失败&quot;); } })}, function(v){ console.log(v)}).then(function(){ console.log(4)}, function(){ console.log(5)}) Promise.all()Promise.all() 方法用于将多个 Promise 实例，包装成一个新的Promise 实例。1const p = Promise.all([p1, p2, p3]); Promise.all() 方法接受一个数组作为参数， p1 、 p2 、 p3 都是 Promise 实例，如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all() 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是Promise 实例。p 的状态由 p1 、 p2 、 p3 决定，分成两种情况。 只有 p1 、 p2 、 p3 的状态都变成 fulfilled ， p 的状态才会变成 fulfilled ，此时 p1 、 p2 、p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1 、 p2 、 p3 之中有一个被 rejected ， p 的状态就变成 rejected ，此时第一个被 reject的实例的返回值，会传递给 p 的回调函数。 实例： 12345678910111213141516var p1 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('1111') },1000)});var p2 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('22222') },4000)}); Promise.all([p1,p2]).then(([d1,d2])=&gt;{ console.log(d1,d2);},err=&gt;{}); Promise.race()1const p = Promise.race([p1, p2, p3]); 只要 p1 、 p2 、 p3 之中有一个实例率先改变状态， p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。Promise.race() 方法的参数与 Promise.all() 方法一样，如果不是 Promise 实例，就会先调用下面讲到的 Promise.resolve() 方法，将参数转为 Promise 实例，再进一步处理。 123456789101112131415var p1 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('1111') },1000)});var p2 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('22222') },4000)});Promise.race([p1,p2]).then(d =&gt;{ console.log(d);},err=&gt;{});","link":"/2022/08/13/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Promise/"},{"title":"数组常用属性和方法","text":"最近因为基础卡住了，补课~ 创建数组 new关键字方式12//使用 JavaScript 关键词 newvar color= new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;); 字面量方式12//使用数组文本创建var color2 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; 在数组中添加值与获取值123456789//数组中添加值color2[3] = 'abc';color2[4] = 'xyz';//获取color2[3] ;//'abc';//获取数组最后一个元素color2[color2.length-1];//获取数组长度color2.length; //5 数组中的方法数组转字符串 如果转成【逗号】号拼接，这个最简单 123//toString() 把数组转换为数组值（以逗号分隔）的字符串。var arr1 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr1.toString(); //&quot;red,blue,green&quot; 如果想用其他符号拼接，用这个 1234//join() 方法也可将所有数组元素结合为一个字符串，可以自定义分隔符var arr2 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];console.log(arr2.join(&quot;:&quot;)) //red:blue:greenconsole.log(arr2.join(&quot; &quot;)) //red blue green 增删改数组元素 添加新元素 在开头添加123//unshift() 方法（在开头）向数组添加新元素 var arr3 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr3.unshift(&quot;abc&quot;);//[&quot;abc&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] 在结尾添加12//push() 方法（在数组结尾处）向数组添加一个新的元素arr3.push(&quot;xyz&quot;); //[&quot;abc&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;,&quot;xyz&quot;] 删除元素 从后面删123//pop() 方法从数组中删除最后一个元素 pop()返回的是被弹出的值var arr4 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr4.pop(); //&quot;green&quot; arr4 ======[&quot;red&quot;, &quot;blue&quot;] 从开头删12//shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引，返回的是被弹出的值arr4.shift();//&quot;red&quot; 修改元素1234567891011//splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素则返回的是含有被删除的元素的数组var arr5 = [5,6,7,8];// arr5.splice(位置,个数,添加的新元素)arr5.splice(1,1); //删除了6 arr5 的结果是[5,7,8]arr5.splice(1,0,9);//arr5 的结果是[5, 9, 6, 7, 8]arr5.splice(1,2,3);//arr5 的结果是 [5, 3, 8]//slice()返回一个新的数组，包含从 start 到 end （不包括该元素）的arrayObject 中的元素var arr6 = [5,6,7,8];arr6.slice(1,3) //[6, 7]//arr6 仍然还是[5,6,7,8]; 返回的是选定的元素，该方法不会修改原数组 合并数组12345//concat() 方法用于连接两个或多个数组 该方法不会改变原有的数组var arr7 =[1,2,3];var arr8 = [4,5,6];var arr9 = arr7.concat(arr8);//arr9 [1, 2, 3, 4, 5, 6] 排序123456789//sort()排序var arr10 =[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr10.sort(); // [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;]var arr11 = [1,10,5,12,4,9,22];arr11.sort();// [1, 10, 12, 22, 4, 5, 9]//reverse() 方法用于颠倒数组中元素的顺序 会改变原数组arr11.reverse();// [22, 9, 4, 12, 5, 10, 1] 遍历数组for循环1234567891011121314//for循环遍历var arr12 =[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];var str = &quot;&quot;;for(var i=0;i&lt;arr12.length;i++){ str += &quot;&lt;p&gt;&quot;+arr12[i]+&quot;&lt;/p&gt;&quot;};document.getElementById(&quot;test&quot;).innerHTML= str;//forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。var arr13 =[1,2,3];var a14=[];arr13.forEach(function(item,index){ //item=1 2 3 a14.push(item+1);});console.log(a14); 筛选数组12345678910111213141516171819//filter()对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的组var arr15 = [2,3,5,6,7,18,9];var a15 = arr15.filter(function(item,index){ return item &gt;5; //满足的条件 大于5的结果[6, 7, 18, 9]});类似于&amp;&amp;//every()对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true//每一项都满足条件时返回true,只要有一个不满足返回falsevar a16 = arr15.every(function(item,index){ //return item &gt;5; //必须要求每一个数字都&gt;5才会返回true 否则 false return item&gt;1; //true});类似于||//some()只要有一个满足返回true,都不满足返回falsevar a17 = arr15.some(function(item,index){ //return item &gt;5; //只要有一个满 足了条件，返回true return item==0; //false 都不满足 返回false});","link":"/2022/05/29/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"},{"title":"最近的一点感悟","text":"最近工作很累，至于为什么累呢，我想到几个原因 心态 把心态拿到第一点来说，是因为它真的太重要了，好的情绪可以让你事半功倍，做事情都十分有效率，每个人都会遇到困难与挑战，就看你怎么去面对它，用乐观积极的心态去看待问题，可能暂时解决不了问题，但是会让心情放松，在一定程度上是好的，在这种心态下解决问题也会顺利，如果是很丧的，你周围的气压都是不一样的，自己的心情都是郁闷的，自然做起事来，只要有一点没有做好，就会给自己施压，消极的情绪就放大了，事情也变得糟糕难以解决了，试想你自己都厌恶自己，又有谁愿意与你一起共事呢，自爱才能他爱，所以要训练自己调节心态的能力。 这个项目才中点，我的情绪已经崩了两次了，实在是不应该，我很欣赏我对面的两位前端兄弟，记得有一次他们打开禅道，在打赌说谁bug多一些，bug多的那个人请喝饮料，打开一看，一个人120多个bug，另一个人70多个，本来不太热的办公室，我看到他们俩开始用本子扇起风来，那动作那么的一致（因为两个人都是胖胖的，又一起扇风，难兄难弟的感觉）看得我觉得有趣，于是我问，你们热吗，怎么还扇起来”扇子“了，我对面那个兄弟回答道：你看到这么多bug你不上火吗，我：哈哈哈哈哈。面对困难的不止我一个人，用调侃的方式去看待这些问题何尝不是一件好事呢，总归，不管用什么方式，问题一定是可以解决的，技术层面达不到那就寻求人为层面的方式，这需求实现不了~哈哈。 交流 有一段时间我认为交流毫无用处，写代码就写呗，好好思考技术问题，总是说、交流写的完么？交流那么多干什么？甚至不喜欢的人就不想去交流，除非必须要我去交流的事情我才会去交流，其他的时候就让我得测试代劳去沟通，可能因为关系还不错，我的测试大部分时候已经默认了这种行为。我得一位同事是从别的项目组来的，他因为不熟悉这个项目组的成员，慢慢的也变得和我一样，但是他说起来他之前的项目组，项目经理会把项目成员叫一起开会沟通，其实也和我们差不多，我们也会在项目开始的时候开会沟通，至于在项目过程中是如何操作的，那就不太清楚了，可能以后还会再和他交流相关的话题。这样发生的问题还是有一些的，自己思考难免陷入僵局，或者走进死胡同，而且还有和测试一起合谋漏掉需求的时候，最后被项目经理问起来也是很尴尬的。 让我走出交流无用认知，还是发生了一些事情的，比如遇到了问题自己想了很久也没有想明白，和同事讲了一下，可能好的解决办法并不是用更复杂的技术问题去解决他，换一种思考方式就好解决了，比如同事遇到了问题，向我寻求帮助，我这个局外人很容易看出来问题出在需求，让同事去沟通一下，问题也很好解决了，比如你做过一个需求，当然也是花时间研究过的，同事没有做过这种需求正在挠头，你的几句点拨就让他豁然开朗了，同事就可以按时下班了😏而且和有趣的人交流也可以放松心情，抚慰心灵，下一次你遇到困难的时候不妨和身边的人聊聊天，休息一下，就这一小会儿并不会耽误什么时间，可能正因为这样小小的放松休憩，接下来的工作就会迎刃而解了。 以上的心态和交流的问题如果解决了，其实可以节省出来大量的时间，这次项目我反而是因为这两者浪费了很多时间，还导致了项目延期🤭 难点 拿到我不熟悉的项目确实让我有一些压力，商城应该算to c类型的项目吧，总体来说绘制页面并不是很难，倒是组件和数据结合的时候，我懵了，因为在绘制组件的时候，我还是没有看接口文档的，具体数据结构是什么，在绘制页面的过程中我认为只要能按我写的数据渲染到页面上，到时候调接口我怎么也是可以把他拼成我现在写的这样的是吧，实践过程中有些是可以这样的，当然还是在心态好的时候更容易写出来，心态不好的时候居多，还有一些可能是对需求的理解不是很深入，不想交流，封闭自己，上面也说了，面临的事情不言而喻了。 页面绘制中，像带缩略图的swiper、列头带下拉框的table、table树、富文本、照片墙、标签组可单选复选、页面结构拆的要多细、组件封装的程度、多级路由出口在哪里、权限配置等等，这才只做了一半，很多问题都显现出来了，要思考的东西很多，之后要思考的东西也很多，想要做完项目好好的来一个总结的，在过程中先把稀碎的点记录下来。 接口联调中，如何熟练运用接口的组合，可能后端提供的方式并不是最适合前端的，怎样合理的运用接口，这是其中一个问题遇到的状况，还有的时候是缺乏沟通错误的运用了接口，造成一些逻辑还要重写，树形数据结构递归，树的子节点拼接，遍历嵌套数据，键与值结构的花样变换，对UI组件的熟悉程度，对vue原理的熟悉程度，对webpack的熟悉程度，对路由守卫的熟悉程度等等技术问题也需要去思考。 写在最后 从21年6、7月进入项目组，前期运维工作居多，那个时候也没有和项目组的成员坐到一起，一直都是远程交流的，刚进来有一点不熟悉，但是也很快克服了那个阶段，后面又接了一些项目，比之前有一定难度，但是项目结构大致差不多，有难点却不那么集中，有思考分析的时间，所以倒也没有那么难，再到这个项目前后台两端，还是我第一次接触，对我技术成长有很大的帮助，短时间内要集中解决众多难点，还是有挑战。 虽然项目过半，我没有按期完成，但是通过这次的总结，我明白了应该怎么去做好后面的工作，而且在工作中每一个小小的进步都会让我发自内心的开心与肯定自己，正如墨菲定律中的不值得定律说的那样：“一个人如果在做一件自认为不值得做的事情，即使成功，也不觉得有多大的成就感；如果在做自认为值得做的事情，则会认为每一个进展都很有意义。”朋友圈中有的朋友会吐槽工作、领导多么的sb，有的朋友会发自内心热爱和表达出对工作的热情与喜爱，我想我应该是后者吧，也许有坎坷和苦闷，排除之后留下的更多是开心，我也不悔工作这三年的选择。 在项目中也交到了朋友（最近也零零散散的在看和交友有关的视频和书籍），一位忠实的良师益友比任何财富都重要，感谢协助我搭建博客的朋友，支持鼓励督促我变得更好的朋友🥰 我更应该好好培植与爱护我的“果树”。 想把这个项目作为我在这里三年的最后总结，抱着好好道别的心态，多么不想搞砸的，也可能是给自己的压力过于大了，越想做好的事情越紧张，反而并没有想象中那么好了。过去已然过去了，一万年又太久，只争朝夕吧~","link":"/2022/06/02/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"感悟","slug":"感悟","link":"/tags/%E6%84%9F%E6%82%9F/"},{"name":"思考","slug":"思考","link":"/tags/%E6%80%9D%E8%80%83/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"日常记录","slug":"日常记录","link":"/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]}