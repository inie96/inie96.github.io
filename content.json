{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"About The Blog","text":"喜欢阅读📚 喜欢大自然🌿 喜欢挑战自己🏆 喜欢可爱美好的事物🦁 努力成为自己的小太阳ing🌞","link":"/about/index.html"},{"title":"About The Plan","text":"","link":"/plan/index.html"},{"title":"","text":"sup { position: relative; top: -0.4em; vertical-align: baseline; } sub { position: relative; top: 0.4em; vertical-align: baseline; } a:link {text-decoration:none;} a:visited {text-decoration:none;} @media screen and (min-device-pixel-ratio:0), (-webkit-min-device-pixel-ratio:0), (min--moz-device-pixel-ratio: 0) { .view { font-size:10em; transform:scale(0.1); -moz-transform:scale(0.1); -webkit-transform:scale(0.1); -moz-transform-origin:top left; -webkit-transform-origin:top left; } } .layer { }.ie { font-size: 1pt; } .ie body { font-size: 12em; } .stl_01 { position: absolute; white-space: nowrap; } .stl_02 { height: 70.08334em; font-size: 1em; margin: 0em; line-height: 0.0em; display: block; border-style: none; width: 49.58333em; } .stl_03 { position: relative; } .stl_04 { position: absolute; left: 0em; top: 0em; } .stl_05 { position: relative; width: 49.58333em; } .stl_06 { height: 7.008333em; } .ie .stl_06 { height: 70.08334em; } @font-face { font-family:\"MMPWKS+MicrosoftYaHei-Bold\"; src:url(\"3371fe3b-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_07 { font-size: 1.829167em; font-family: \"MMPWKS+MicrosoftYaHei-Bold\", \"Times New Roman\"; color: #44546B; } .stl_08 { line-height: 1.041992em; } .stl_09 { letter-spacing: 0.0004em; } .ie .stl_09 { letter-spacing: 0.0125px; } @font-face { font-family:\"DIKHKL+MicrosoftYaHei\"; src:url(\"1b0cfbf9-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_10 { font-size: 1em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #525252; } .stl_11 { letter-spacing: -0.0036em; } .ie .stl_11 { letter-spacing: -0.0582px; } @font-face { font-family:\"AJAHDD+MicrosoftYaHeiLight\"; src:url(\"ec0f8afa-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_12 { font-size: 0.870833em; font-family: \"AJAHDD+MicrosoftYaHeiLight\", \"Times New Roman\"; color: #525252; } .stl_13 { letter-spacing: 0em; } .ie .stl_13 { letter-spacing: 0px; } .stl_14 { letter-spacing: -0.2519em; } .ie .stl_14 { letter-spacing: -3.5103px; } .stl_15 { letter-spacing: -1.007em; } .ie .stl_15 { letter-spacing: -14.0303px; } .stl_16 { letter-spacing: -0.046em; } .ie .stl_16 { letter-spacing: -0.6408px; } .stl_17 { letter-spacing: -0.0905em; } .ie .stl_17 { letter-spacing: -1.2611px; } .stl_18 { letter-spacing: -0.1571em; } .ie .stl_18 { letter-spacing: -2.1883px; } .stl_19 { font-size: 1.079167em; font-family: \"MMPWKS+MicrosoftYaHei-Bold\", \"Times New Roman\"; color: #FFFFFF; } .stl_20 { letter-spacing: -0.0003em; } .ie .stl_20 { letter-spacing: -0.0054px; } .stl_21 { font-size: 1em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #585858; } .stl_22 { letter-spacing: 0.0005em; } .ie .stl_22 { letter-spacing: 0.0083px; } .stl_23 { font-size: 0.870833em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #585858; } .stl_24 { letter-spacing: -0.0004em; } .ie .stl_24 { letter-spacing: -0.0062px; } .stl_25 { letter-spacing: 0.0018em; } .ie .stl_25 { letter-spacing: 0.0255px; } .stl_26 { letter-spacing: 0.001em; } .ie .stl_26 { letter-spacing: 0.014px; } .stl_27 { letter-spacing: 0.0047em; } .ie .stl_27 { letter-spacing: 0.0662px; } .stl_28 { letter-spacing: 0.0029em; } .ie .stl_28 { letter-spacing: 0.041px; } .stl_29 { letter-spacing: 0.0036em; } .ie .stl_29 { letter-spacing: 0.0504px; } .stl_30 { letter-spacing: -0.0008em; } .ie .stl_30 { letter-spacing: -0.0115px; } .stl_31 { letter-spacing: 0.0011em; } .ie .stl_31 { letter-spacing: 0.0147px; } .stl_32 { letter-spacing: -0.0075em; } .ie .stl_32 { letter-spacing: -0.1049px; } .stl_33 { letter-spacing: 0.0022em; } .ie .stl_33 { letter-spacing: 0.0307px; } .stl_34 { letter-spacing: -0.0051em; } .ie .stl_34 { letter-spacing: -0.0705px; } .stl_35 { letter-spacing: 0.0044em; } .ie .stl_35 { letter-spacing: 0.0609px; } .stl_36 { font-size: 0.870833em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #595959; } .stl_37 { letter-spacing: 0.0038em; } .ie .stl_37 { letter-spacing: 0.0524px; }","link":"/resume/style.css"},{"title":"文章标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"for of的使用","text":"详见下文 for of 可以代替forEach for( let [i,v] of arr.entries)加不加中括号的区别？数组使用解构的写法去写？看你拿到的数据是什么情况的，判断是不是能够用解构的方式取到键值如果拿到的数据不行，就要转换一下arr.entries() 对象运用for of本来不能用 因为对象没有遍历器要把对象转换一下用Object.entries(obj)1234567891011121314151617var obj = {id:1,name:'abc'};for (let k in obj) {console.log(k);console.log(obj[k]);}for (let k of obj) {console.log(k);}// TypeError: es6[Symbol.iterator] is not a function解决的办法for (let [k,v] of Object.entries(obj)) {console.log(k); //获取键console.log(v); //获取值} 与其他遍历的比较for：取值不方便forEach：取值方便，但是不能添加返回，无法中途退出循环map：有返回值for in：获取值的时候还要用另一个方式，有一点麻烦1234for （let i in arr）{console.log(i); //获取键console.log(arr[v]); //获取值} for of 可以直接添加 break continue","link":"/2023/03/23/for-of%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"promise和generator语法糖-async await","text":"有了 async-await、promise 还有必要学习吗? async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性。简单来说：async-await 是建立在 promise机制之上的，并不能取代其地位。 async1234async function timeout() { return 'hello world'} timeout(); //为什么没有执行'hello world' 1234async function timeout() { return 'hello world'}console.log(timeout()); //Promise {&lt;resolved&gt;: &quot;hello world&quot;} async 函数返回的是一个promise 对象，如果要获取到promise 返回值，应该用then 方法 12345678async function fn(){ return 100;}console.log(fn()); //Promise {&lt;resolved&gt;: 100}let f = fn();f.then(function(d){ console.log(d) //100}) awaitawait操作符用于等待一个Promise对象，它只能在异步函数async function内部使用。返回值：返回promise对象的处理结果，如果等待的不是promise对象，则返回该值本身如果一个promise被传递给一个await操作符，await将等待promise正常处理完成并返回其处理结果 12345678910function f2(){ console.log(4)}async function f(){ await f2(); console.log(2) }f();console.log(3);// 4 3 2 正常情况下，await命令后面是一个promise对象，它也可以是其它值，如字符串，布尔值，数值以及普通函数。 123456789console.log(2)async function fn(){ console.log(3) await 100; console.log(1)}fn()console.log(4)// 2 3 4 1 await命令后面是一个promise对象 12345678910111213function p(){ return new Promise(resolve=&gt;{ resolve(); console.log(1) });};async function fn(){ console.log(2) await p(); console.log(3)}fn()// 2 1 3","link":"/2022/08/13/promise%E5%92%8Cgenerator%E8%AF%AD%E6%B3%95%E7%B3%96-async-await/"},{"title":"markdown语法","text":"10个你需要了解的md语法 1、标题 语法： 123456789# + 文字（最多到6级标题）# 标题1 ### 标题2 ##### 标题3 ####### 标题4 ######### 标题5 ########### 标题6 ####### 效果 标题1标题2标题3标题4标题5标题62、列表 无序列表 语法： 1234567891011+ a+ b+ c- d- e- f* g* h* i 效果 a b c d e f g h i 有序列表 语法： 123456789有序列表1. abc2. abc3. dada错序列表2. awfa5. awef25. dfaf 效果 有序列表 abc abc dada 错序列表 awfa awef dfaf 嵌套列表 语法： 1234567891011121314无序+ a + a1 + a2+ ba+ c有序1. a 1. adac 1. adaw 2. adfsda2. ad3. sad 效果 无序 a a1 a2 ba c 有序 a adac adaw adfsda ad sad 3、引用块 语法： 1234567引用&gt; 引用1引用1 引用1嵌套引用&gt; 嵌套引用1&gt;&gt; 嵌套引用1 效果 引用 引用1引用1 引用1 嵌套引用 嵌套引用1 嵌套引用1 4、代码块 语法： 1234567891011代码块// code`code`code多行代码块儿// ```// code// code// code// ``` 效果 代码块codecodecode 多行代码块儿 123codecodecode 5、链接 语法： 12链接[百度1](www.baidu.com) 效果 链接百度1 6、图片 语法： 1![图片](https://note.youdao.com/favicon.ico) 效果 7、分割线 语法： 12345678分割线---- - --------****** * *____ 效果 分割线 8、表格 语法： 1234567891011121314151617181920表格1|123|234|345||:-|:-:|-:||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde|表格2|123|234|345||:---|:---:|---:||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde|表格3123|234|345:-|:-:|-:abc|bcd|cdeabc|bcd|cdeabc|bcd|cde 效果 表格1|123|234|345||:-|:-:|-:||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde|表格2|123|234|345||:—|:—:|—:||abc|bcd|cde||abc|bcd|cde||abc|bcd|cde|表格3123|234|345:-|:-:|-:abc|bcd|cdeabc|bcd|cdeabc|bcd|cde 9、复选框 语法： 12- [ ] 复选框- [x] 选中状态 效果 复选框 选中状态 10、其他 语法： 1234567891011121314151617斜体*md*粗体**md**斜体_md_斜体__md__转义\\+删除线~~删除~~ 效果 斜体md 粗体md 斜体md 粗体md 转义+ 删除线删除","link":"/2022/09/08/markdown%E8%AF%AD%E6%B3%95/"},{"title":"作用域","text":"详见下文 定义 作用域:它是指对某一变量和方法具有访问权限的代码空间, 在JS中, 作用域是在函数中维护的。表示变量或函数起作用的区域,指代了它们在什么样的上下文中执行,亦即上下文执行环境。ES5的作用域只有两种:全局作用域和局部作用域(又名函数作用域) 123456789101112全局作用域var a=1; //全局作用域function fn1(){ console.log(a)};fn1()局部作用域function fn1(){ var a=1; //局部作用域};fn1();console.log(a); 生命周期：全局：浏览器关闭前都生效局部：仅在函数执行时生效，函数执行完毕回收 局部不断去享受父作用域的值，父享受不了子的值 123456789101112var a = 1; //全局作用域function f1(){ var b = 2; //局部作用域 b属于f1下的作用域 function f2(){ var c = b; //局部作用域 c属于f2下作用域 b = a; a = c; console.log(a,b,c) //2 1 2 }; f2();};f1(); 扩展 1234567891011121314151617181920212223242526272829303132333435//1)var a = 1;function f1(){ console.log(a);};f1(); //1//2)function f1(){ var a = 1;};f1(); console.log(a); //a is not defined//3)注意打印第二个avar a = 1;function f1(){ console.log(a); //1 a = 2; //改变全局变量的值};f1();console.log(a); //2//解析过程 //预解析var a;function f1(){}//逐行解析a = 1;f1();//函数执行console.log(a); //1a = 2;console.log(a); //2 全局变量和局部变量同名的坑(1)在全局变量和局部变量不同名时，其作用域是整个程序。(2)在全局变量和局部变量同名时，全局变量的作用域不包含同名局部变量的作用域。 1234567891011121314151617181920212223//4)var a = 1;function f1(){ console.log(a); //undefined var a = 2; //在全局变量和局部变量同名时，全局变量的作用域不包含同名局部变量的作用域。};f1();console.log(a); //1//解析过程 //预解析var a;function f1(){}//逐行解析a = 1;f1();//函数执行//预解析var a;console.log(a); ////undefineda = 2;console.log(a); //var a = 1; 1 123456789101112131415161718192021222324252627//经典作用域面试题一var a = 10; function f1(){ var b = 2 * a; var a = 20; var c = a+1; console.log(b); console.log(c); };f1();//解析过程 //预解析var a;function f1(){}//逐行解析a = 10;f1()//函数执行//函数内部的预解析var b;var a;var c;////逐行解析b = 2*a; //a = undefined 在全局变量和局部变量同名时，全局变量的作用域不包含同名局部变量的作用域a = 20;c = a+1;console.log(b); //NaNconsole.log(c); //21 12345678910//经典作用域面试题二var a=10; function test(){ console.log(a); //undefined a=100; //在全局变量和局部变量同名时，全局变量的作用域不包含同名局部变量的作用域 console.log(this.a); //this 指向window 10 var a; console.log(a); //100}test();","link":"/2023/03/23/%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"函数式编程与面相对象编程","text":"详见下文 js是解释型或即时编译型的高级编程语言支持面相对象、命令式和声明式（函数式）编程风格 函数式写法 sum(){ return n1+n2} 面相对象写法（构造函数、ES6里的class类） 对象 字面量方式 好管理 复用过程中好引用不用一个个引入， 对象定义方式嵌套字面量写法简单字面量写法 案例——放大镜功能实现 12345678910111213141516171819202122232425262728293031函数式函数式的写法先会了再放到面向对象方式处理滑块的显示隐藏面相对象变更成面相对象的写法定义对象 字面量的方式var obj = { id:1, action:function(){}}this 指针在函数内部运行过程中会自动生成一个内部的对象this 指针只在函数内部生成this在回调函数、定时器等里面指向window面相对象变化2var obj = { $:function(){} init:function(){} mouseleave:function(){} mousemove:function(){}}分模块开发的思想代码要分块看最开始调用了什么这里面定义了什么","link":"/2023/03/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"title":"原型是一个对象","text":"详见下文 原型：通过原型实现继承JS对象分两种普通对象object函数对象function__proto__是每个对象都有的属性prototype是函数才有的属性（原型只有函数才有的属性） 普通对象和函数对象的区别用typeof类型判断函数的实例化对象也是一个普通对象object 12345678function f1(){};// 构造函数typeof f1 //&quot;function&quot;var o1 = new f1(); // 实例化的是普通对象，不是函数对象typeof o1 //&quot;object&quot;var o2 = {};typeof o2 //&quot;object&quot; 构造函数 首字母大写 函数内部用到this 必须要对构造函数实例化处理 12345678构造函数(构造器) 类 抽象function Person(name,age){ this.name = name this.age = age}实例化var x = new Person('x',20)（实例化的是普通对象，不是函数对象 所以没prototype） 如果不实例化，就是构造的人，并非真实的人，梦中的人 为什么要用prototype？为什么要继承？创建多个对象 1234567891011var o1 ={ name:'o1', id:1, age:1,}var o2 ={ name:'o2', id:2, age:1,}// 缺点 实例太多写起来麻烦，且实例和原型没有关联（没有共享和公共）如果要添加属性和方法就很麻烦 封装一个函数 复用 12345678910function Cat(name,id,age){ return { name:name, id:id, age:age }}var o1 = Cat('o1',1,1)// 缺点 不知道实例是否来自同一个原型对象，不能知道是不是来自一个祖先，不能共享祖先带来的一些福利（继承他的属性和方法）// 优点 要添加属性和方法就很方便 构造函数 123456789function Cat(name,id,age){ //构造函数 this.name = name; this.id:id; this.color = color; this.type = '动物'; this.eat = function(){console.log('吃鱼')}};var cat1 = new Cat('o1',1,1); //实例化var cat2 = new Cat('o2',2,1); 优化构造函数 12345678910111213function Cat(name,id,age){ this.name = name; this.id:id; this.color = color; //this.type = '动物'; //this.eat = function(){console.log('吃鱼')}};Cat.prototype.type = '动物';Cat.prototype.eat = function(){console.log('吃鱼')};var cat1 = new Cat('o1',1,1);var cat2 = new Cat('o2',2,1);// 优点 实例都享受原型上的属性和方法（公共的提出来）都放在里面浪费内存，对每个实例来说这个方法和属性都是一模一样的，不环保，缺乏效率 重构？重构的是什么？考虑一些公共的功能提取出来 原型分解图 12341、每一个函数对象都有一个prototype属性，但是普通对象是没有的；prototype下面又有个constructor，指向这个函数。2、每个对象都有一个名为__proto__的内部属性，指向它所对应的构造函数的原型对象，原型链基于__proto__; 构造函数和原型对象的不同 1234567cat是构造函数，cat.prototype是构造函数的原型对象构造函数的属性和方法不能共享原型对象的属性和方法可以被所有实例对象去共享构造函数是生成对象的模板，一个构造函数可以生成多个对象，每一个对象会有相同的结构（属性方法）原型对象可以不断去定义你需要的资源（属性方法）（不浪费内存、环保） 验证属性方法是自身的还是原型对象的12345console.log('name' in p1); //in 不管自身的还是原型 都返回trueconsole.log('type' in p1);console.log(p1.hasOwnProperty('name')); //hasOwnProperty() 自身返回true 原型 返回falseconsole.log(p1.hasOwnProperty('type')); 继承的多种方式 读取对象的属性时优先读取自身的属性，如果找不到再去原型找，直到最顶的Object.prototype 如果对象自身和他的原型都定义了同名属性，优先取对象自身的属性 原型继承12345678910111213141516function Animal(){ //Animal构造函数this.type = &quot;动物&quot;};function Cat(name,color){ //Cat构造函数this.name = name;this.color = color;};Cat.prototype = new Animal();// 共有的动物特性提出来，凡是动物都可以享受其中属性，// Cat.prototype cat的原型对象 = new Animal()// 这样写让动物和猫产生了继承的关系var c1 = new Cat('x','白色');var c2 = new Cat('t','花色');c1.type优点：同一个原型对象缺点：不能修改原型对象，会影响所有实例 构造函数的继承 1234567891011121314151617function Animal(){this.type = &quot;动物&quot;};function Cat(name,color){Animal.apply(this); //将Animal对象的成员放到Cat对象上this.name = name;this.color = color;};var cat1 = new Cat(&quot;大明&quot;,&quot;黄色&quot;);var cat2 = new Cat(&quot;小明&quot;,&quot;白色&quot;);cat1.type = '我是黄猫';cat2.__proto__.type = '我是动物';console.log(cat1.type); //'我是黄猫' cat1被修改console.log(cat2.type); //&quot;动物&quot;优点：不存在修改原型对象影响所有实例，各自拥有独立属性缺点：父类的成员会被创建多次，存在冗余且不是同一个原型对象通过apply/call只能拷贝成员，原型对象不会拷贝 组合继承 123456789101112131415161718function Animal(){this.type = '动物'};Animal.prototype.eat = function(){console.log('吃')};function Cat(name,color){this.name = name;this.color = color;Animal.call(this);};Cat.prototype = new Animal();var cat1 = new Cat(&quot;大明&quot;,&quot;黄色&quot;);var cat2 = new Cat(&quot;小明&quot;,&quot;白色&quot;);cat1.type = '我是黄猫'; //修改当前构造器中的属性cat2.__proto__.type = '我是动物';//修改了原型对象的值，但并不影响cat1,cat2的值console.log(cat1.type); //'我是黄猫' //原型对象的值变化，并不影响构造函数值console.log(cat2.type); //'动物'console.log(cat2.__proto__.type); //'我是动物cat1.eat(); //还可以调用原型对象中eat()方法 原型是一个对象 ES5没有类类就是一个抽象的对象 ES6里可以用class定义类 那ES5里面怎么定义抽象的对象？构造函数？ 用原型实例指向创建对象的类 适用于创建新的对象的类时 共享原型的属性和方法原型是一个对象 其他对象可以通过它实现属性继承 原型为了实现属性继承出现的 JS里面一切皆对象 JS对象氛围两类普通对象object 函数对象function prototype是函数才有的属性__proto__是每个对象都有的属性 普通对象和函数对象区分用typeof类型判断 123456789101112131415161718构造函数function f1(){};//函数对象typeof f1 //&quot;function&quot;构造函数实例化var o1 = new f1(); //函数实例（函数的实例对象也是普通对象，并非是函数对象）typeof o1 //&quot;object&quot;var o2 = {};typeof o2 //&quot;object&quot;//普通对象 var o = {};//函数对象function f(){} // var f = function(){}//实例是普通对象var f1 = new f(); 具体原型的写法12345function Person(){}; //定义一个函数对象Person.prototype.name=&quot;abc&quot;; //原型对象中添加属性Person.prototype.action=function(){} //原型对象中添加属性var p1 = new Person(); //实例化 var p2 = new Person(); 构造函数（构造器） 首字母大写 里面会用到this变量1","link":"/2023/03/23/%E5%8E%9F%E5%9E%8B%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/"},{"title":"史上最全hexo博客搭建步骤详解","text":"我的第一篇博客，先给hexo~ 前言本篇讲解主要参考codesheep的关于hexo搭建的视频，结合自己踩的一些坑，综合各路大神的指南而成，如果你在实践本篇博文的过程中有任何问题，欢迎和我一起交流~ 搭建博客的目的： 明确我们的目标才不会让你半途而废 社招、校招加分项 追求极客范儿 挑战自己，我很棒 总览一下我们搭建hexo博客的步骤： 搭建node.js环境 安装加速包cnpm hexo安装 使用hexo搭建博客 新建第一篇博文 把博客部署到github 博客换肤以上就是博客搭建过程概览 下面我们按照上面的步骤逐一实现，你也可以拥有属于自己的博客哟~操作的过程中先不用问太多为什么，照做就行了 1、搭建node.js环境1.1 下载node.jshexo是node.js生成的，需要node.js环境 nodejs官网：nodejs.org nodejs官网图 建议：不要下载最新的node版本，我下载的12版本的 12版本list图 自动安装包格式.pkg 傻瓜安装，一直点同意就好了 安装的结果实际上安装了两个文件一个是node.js另一个是npm包管理器,这是搭建hexo必备 1.2 查看安装的node与npm版本 打开终端 12查看node版本：输入 node -v查看npm版本：输入 npm -v 这里codesheep是在root用户下操作的，但是到后面我使用编辑器操作文件会有点麻烦，总是需要root权限，所以这个因人而异吧 啰嗦一句~每次我们安装或者操作什么都要及时检查这个操作是否成功，程序员基操吧 2、安装加速包cnpm因为国内镜像源的安装速度慢，所以我们安装一个淘宝镜像源，为一会安装hexo速度快 2.1利用npm安装cnpm1输入 npm install -g cnpm --registry=https://registry.npm.taobao.org 2.2查看cnpm版本1输入 cnpm -v cnpm版本截图 3、hexo安装3.1用cnpm安装hexo1输入 cnpm install -g hexo-cli 3.2查看hexo版本1输入 hexo -v 图 4、使用hexo搭建博客4.1建一个空的文件夹blog这个文件夹是存放我们博客所有内容的，那么在建文件夹前先看一下我们当前的位置，方便后续寻找我们的blog文件夹在哪 1查看当前位置：输入 pwd 图 123新建blog文件夹：输入 mkdir blog进入blog：输入 cd blog查看当前位置：输入 pwd 此时我们的路径是/blog结尾，接下来是在这个blog文件初始化我们的hexo 4.2 初始化hexo1初始化hexo：输入 init hexo 此时可以看到克隆到了hexo文件和默认landscape主题 进入blog文件查看初始化都自动生成了哪些文件，后续我们写博客都基于这里面的文件，瞅一眼有啥就行 4.3启动博客1启动hexo:输入 hexo s 此时终端会出现 http://localhost:4000/ 表示我们再本地已经启动成功博客，点这个链接进来看看我们搭建的博客以上我们的博客就搭建完成了，是不是没那么难~ 博客有了我们开始写文章吧~5、新建第一篇博文5.1 创建博文1新建博文：输入 hexo n &quot;你的博文标题&quot; 可以看到我们的博文被创建到source/_posts目录下了，并且是.md格式的，到编辑器(我使用的是vscode)里面打开这个文件，开始写你的第一篇博文吧~ 5.2 查看你完成的第一篇博文写完之后，再次启动一下我们的博客，在本地查看我们新写的一篇博文 看下当前你的位置 1输入 pwd 我们后面的操作依然要回到blog文件下面 接着输入 hexo clean 清理一下 1输入 hexo g 生成一下 先不要问为啥，你以后会知道，照做 1输入 hexo s 启动 刷新刚打开的网址，可以看到我们刚写的博文已经出现了 6、把博客部署到github我们想要一个远端地址可以查看我们的博客，推荐github部署方式，免费万岁！ 6.1 创建github仓库网址：github.com 没有账号的自己注册，不赘述啦，毕竟我们的主题是hexo 登录进来 页面右上角，头像的左边👈🏻有个➕号，➕号下拉框里点New repository新建一个仓库 点进来填写Repository name 命名规范：你的用户名.github.io 你的用户名就是旁边的Owner里面写的 比如我的用户名：inie96 那么就是 inie96.github.io 用户部署个人博客的github仓库的命名必须是这个 点 Create repository 创建仓库完成 6.2 安装git部署插件终端进入到blog文件下 1安装git：输入 cnpm install --save hexo-deployer-git 6.3 设置blog文件下的_config.yml文件来编辑器里，找到blog文件下的_config.yml文件 最下面有个# Deployment 找到他 在他下面配置上这三行 1234type: gitrepo: git@github.com:inie96/inie96.github.io.git（这里配置成我们刚创建仓库的ssh地址，注意是ssh）branch: master 图 最终长这样 6.4 向github部署博客终端回到blog 输入 hexo d 接着会提示你输入github账号密码 部署完成后去刷新刚创建的github仓库，此时已经有文件进来了，就是部署成功了 把仓库名拿出来访问inie96.github.io就可以在远端查看博客了~ 以上我们的博客远端部署完成 7、博客换肤7.1 挑选皮肤网址：https://hexo.io/themes/ 7.2 进入喜欢的皮肤的仓库我选的是icarus 仓库地址：https://github.com/ppoffice/hexo-theme-icarus 7.3 下载主题回到终端blog下面 克隆/下载主题：输入 git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus themes/icarus 是我们要下载到的文件位置 此时在文件夹中打开这个路径就可以看到我们下载的主题文件 7.4 给我的博客配置icarus主题修改刚刚我们也改过的blog文件下的_config.yml文件 这个文件还蛮重要 1修改 theme: icarus 修改成themes下的icarus文件名 图 此时我们再次 123hexo cleanhexo ghexo s 在本地查看一下更换的主题 打开 http://localhost:4000/ 查看没有问题，推送到远端 1输入 hexo d 在远端地址查看更改后的皮肤，换肤完成 总结 安装node 安装cnpm 安装hexo 初始化hexo：init hexo 创建hexo博文：hexo n 部署hexo到github 创建github仓库 安装git 配置文件 hexo d 博客换肤 下载主题 git clone 配置文件 hexo d hexo四件套 1234hexo cleanhexo ghexo shexo d 欢迎观看~ 完结撒花~","link":"/2022/05/21/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3/"},{"title":"对象属性和方法","text":"详见下文 123456789101112//在真实生活中，汽车是一个对象。//汽车有诸如车重和颜色等属性，也有诸如启动和停止的方法var car = new Object(); //定义一个对象car.color='white'; //颜色属性car.weight ='1.5t'; //重量属性car.start = function(){ //启动的方法 console.log('启动')};car.stop = function(){ //停止的方法 console.log('停止')}; 1、定义对象的方式123456789101112131415161718192021222324252627//第一种 使用new var person = new Object();person.name = 'alice';person.age = '18';//定义属性的方式有二种，一种以.的方法 二种[]的方式person['age']= '18';person.sing = function(){ console.log('唱')};//第二种方式对象字面量//1)简单字面量var person2 = {};person2.name='jack';person2['age'] = '20';person2.action = function(){ return '我是一个对象'};document.getElementById(&quot;test&quot;).innerHTML = person2.action();//2)嵌套字面量 键名加不加引号是可行的 加引号：属性名字有空格 连接符- 保留字var person3 = { name:'amy', age:18, action:function(){ return this.name }};person3.action() ; //amy 2、属性的获取方式1234567891011121314151617181920212223242526//属性的设置有 . [] .是取自身的属性 []可以是变量var obj = {};obj.name = 'abc';obj['age'] = 20;obj.name;obj['age'];var a = 'age';obj[a]; //20 //枚举属性 for in 遍历对象的属性var obj2 = {name:'abc',age:18,id:1};for(o in obj2){ console.log(o) //获取键名 name age id console.log(obj2[o]); //获取value值 };var arr = ['a','b','c'];for(a in arr){ console.log(a) //得到是索引 0123};//序列化 数据 json字符串的方式来传输 //对象转json字符串 JSON.stringify()//json字符串转对象 JSON.parse()var obj3 = {name:'abc',age:18,id:1};console.log(typeof JSON.stringify(obj3)) //stringconsole.log(typeof obj3); //objectvar str = JSON.stringify(obj3);console.log(typeof JSON.parse(str)); //object 3、对象常用方法123456789101112131415161718192021222324252627282930313233343536373839//hasOwnProperty() 该方法可以判断对象的自有属性是否存在 检测var o = { flag:'a'};o.hasOwnProperty('flag') //返回的结果是布尔 满 足条件true 反之false//assign() 该方法主要用于对象的合并var o2 = {name:'abc',age:18};var o3 = {id:1,address:'武汉'};var o4 = Object.assign(o2,o3);console.log(o4) //{name: &quot;abc&quot;, age: 18, id: 1, address: &quot;武汉&quot;}var o5 = {flag:'a',address:'北京'};console.log(Object.assign(o4,o5)) ;//当属性相同时，后面会覆盖的属性值，属性不相同添加属性//{name: &quot;abc&quot;, age: 18, id: 1, address: &quot;北京&quot;, flag: &quot;a&quot;}//defineProperty()直接在一个对象上定义新的属性或修改现有属性，并返回该对象。var o6 = {};Object.defineProperty(o6,'name',{ value:'张三', writable:false //属性是否可以修改 true可以修改 false只读 });//定义多个Object.defineProperties(o6,{ 'name':{ value:'abc', writable:false }, 'age':{ value:18, writable:false }});o6 //{name:'abc',age:18}//keys() 返回一个由一个给定对象的自身可枚举属性组成的数组var o7 = {name:'abc',age:18};var a2 = Object.keys(o7); //返回的是数组 [&quot;name&quot;, &quot;age&quot;]//values();返回一个给定对象自己的所有可枚举属性值的数组var a3 = Object.values(o7) //[&quot;abc&quot;, 18]//entries();返回一个给定对象自身可枚举属性的键值对数组var a4 = Object.entries(o7) //[[&quot;name&quot;, &quot;age&quot;],[&quot;abc&quot;, 18]] 1234567forforEachmap的区别需要返回值map不需要返回值forEach","link":"/2023/03/23/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"},{"title":"异步编程解决方案-Promise","text":"一篇搞定Promise~ 定义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓 Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。解决 JS中多个异步回调难以维护和控制的问题 Promise 对象有以下两个特点 对象的状态不受外界影响。 Promise 对象代表一个异步操作，有三种状态： pending （进行中）、 fulfilled （已成功）和 rejected （已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承 诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。基本用法Promise 对象是一个构造函数，用来生成 Promise 实例。123456789101112var p = new Promise(function(resolve,reject){ if(true){ //请求成功 resolve('ok') }else { reject('error') }});p.then(function(res){ console.log(res)},function(res){ console.log(res)}) 解释Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。解决回调陷阱12345678910111213141516171819202122let p = new Promise(function(resolve, reject){ if (true){ resolve(&quot;成功&quot;); } else { reject(&quot;失败&quot;); }})p.then(function(v){ return new Promise(function(resolve, reject){ if (true){ resolve(&quot;成功&quot;); } else { reject(&quot;失败&quot;); } })}, function(v){ console.log(v)}).then(function(){ console.log(4)}, function(){ console.log(5)}) Promise.all()Promise.all() 方法用于将多个 Promise 实例，包装成一个新的Promise 实例。1const p = Promise.all([p1, p2, p3]); Promise.all() 方法接受一个数组作为参数， p1 、 p2 、 p3 都是 Promise 实例，如果不是，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all() 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是Promise 实例。p 的状态由 p1 、 p2 、 p3 决定，分成两种情况。 只有 p1 、 p2 、 p3 的状态都变成 fulfilled ， p 的状态才会变成 fulfilled ，此时 p1 、 p2 、p3 的返回值组成一个数组，传递给 p 的回调函数。 只要 p1 、 p2 、 p3 之中有一个被 rejected ， p 的状态就变成 rejected ，此时第一个被 reject的实例的返回值，会传递给 p 的回调函数。 实例： 12345678910111213141516var p1 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('1111') },1000)});var p2 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('22222') },4000)}); Promise.all([p1,p2]).then(([d1,d2])=&gt;{ console.log(d1,d2);},err=&gt;{}); Promise.race()1const p = Promise.race([p1, p2, p3]); 只要 p1 、 p2 、 p3 之中有一个实例率先改变状态， p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。Promise.race() 方法的参数与 Promise.all() 方法一样，如果不是 Promise 实例，就会先调用下面讲到的 Promise.resolve() 方法，将参数转为 Promise 实例，再进一步处理。 123456789101112131415var p1 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('1111') },1000)});var p2 = new Promise((resolve,reject)=&gt;{ setTimeout(()=&gt;{ resolve('22222') },4000)});Promise.race([p1,p2]).then(d =&gt;{ console.log(d);},err=&gt;{});","link":"/2022/08/13/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-Promise/"},{"title":"扩展运算符","text":"详见下文 扩展运算符定义1.字面量是三个点（…）2.是rest参数的逆运算，将一个数组或者对象转为用逗号分隔的参数序列3.主要用于函数调用（太针对性了） 案例——数组的合并 1234567891011121314151617181920var arr1 = [1,2,3];var arr2 = [4,5];ES5方式arr1.concat(arr2);ES6方式法1var arr3 = [...arr1,...arr2] // arr3 [1,2,3,4,5]//...arr1 &lt;=&gt; 1,2,3//数组名前面带...就说明是把数组里面的值取出来了法2var arr4 = arr1.push(...arr2) // arr3 [1,2,3,4,5]不带...的错误拼接方式 变成了二维数组var arr5 = [arr1,arr2] //[[1,2,3],[4,5]]var arr6 = arr1.push(arr2) //[1,2,3,[4,5]]这种方式也是可以的var arr7 = [...arr1,...arr2,...[6,7]]//[1,2,3,4,5,6,7] 为什么和rest参数是逆运算？rest参数用于获取函数的多余参数rest 非数组-&gt;数组扩展运算符 数组-&gt;非数组 参数案例——定义的函数是计算参数的和 12345function sum(n1,n2){ return n1+n2};var arr6 = [10,20];sum(...arr6) //==sum(10,20) 扩展运算符与参数结合案例 1234567function f1(...value){ //...value rest 参数 console.log(value); //[-1,1,2,2,3] console.log(...value); //-1,1,2,2,3};let x1 = [1,2];f1(-1, ...x1, 2, ...[3]); //...x1,...[3] 扩展运算符//f1(-1,1,2,2,3) 扩展运算符与箭头函数结合案例 12345678910111213141516171819202122//面试题 扩展一 求数组对象中ID的最大值var arr7 = [ {id:1,name:'a',date:'2021-06-16',msg:'a'}, {id:2,name:'a',date:'2021-06-16',msg:'a'}, {id:5,name:'a',date:'2021-06-16',msg:'a'}, {id:8,name:'a',date:'2021-06-16',msg:'a'}, {id:3,name:'a',date:'2021-06-16',msg:'a'}];ES6写法var maxId = Math.max(...arr7.map(v=&gt;v.id)); // 8步骤分解1.求最大值使用Math.max(1,10)，注意括号中的值是逗号拼接2.取出ID的值 用循环遍历（此处用了map，map与forEach的区别：map有返回值）var a = arr7.map(function(v){ return v.id});console.log(a); // [1, 12, 5, 8, 3]Math.max(...a);3.把数组中值取出 用扩展运算符4.合并步骤 扩展运算符与解构结合案例 123456const [first, ...rest] = [1, 2, 3, 4, 5];console.log(rest) //[2, 3, 4, 5]const [first, ...rest] = [];console.log(first) //undefinedconsole.log(rest) //[] 扩展运算符与深拷贝（仅针对一维数组）案例 1234567891011非扩展运算var a1 = [1,2,3];var a2 = a1;a2[1] = 100;a1 //[1,100,3]//扩展运算var a1 = [1,2,3];var a3 = [...a1];a1[2] = 999;a3 // [1, 2, 3] 对象中扩展运算案例 12345678910111213141516171819202122232425var o1 = {id:1};var o2 = {name:'o2'};var o3 = {...o1,...o2}; //{id: 1, name: &quot;o2&quot;}var o4 = {...o1,o2}; //{id:1,o2:{name:'o2'}}// vue3应用// setup(){// return {// ...state,// ...abc,// change// }// }var o1 = {id:1};var o2 = {name:'o2'};let f3 =() =&gt;999;var o6 = {...o1,...o2,f3}var o6 = { id:1, name:'o2', f3:function(){ return 999 }}","link":"/2023/03/23/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"数据类型","text":"详见下文 数据类型 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、空对象（Null）、未定义（Undefined）引用数据类型(复杂类型 )：对象(Object)、数组(Array)、函数(Function) 123var x;var x = 5; //声明变量名x 把5的值赋给xvar x ='5'; 基本类型字符串12345678可以在引号中添 加任意文本，命名用单引号或双引号var a = 'a';var b = &quot;b&quot;;var c = &quot;hello world&quot;;var x = '5';var name = '张三';var a = c; //c没有添加引号，表示变量C 所以a的值为&quot;hello world&quot;//alert(a); 数字12var n = 10;var n2 = 10.5; 布尔123只有二个值，true(真)和false(假) 用于条件判断var b1 = true;var b2 = false; 空对象12只有一个值nullvar _n = null; 未定义123var unde;var _unde = undefined;//alert(unde); 复杂类型数组（Array) 存储数据1234567891011121314var arr = new Array(); // 需要通过new关键字来声明其类型arr[0]='a';arr[1]= 2;console.log(arr); // [&quot;a&quot;, 2]//另一种方式var a1 = 'a';var arr2 = new Array(a1,'b',3,5);console.log(arr2); // [&quot;a&quot;, &quot;b&quot;, 3, 5]//简写var c = 'hello world'var arr3 = ['a','c',c,10,11];console.log(arr3[2]) // 获取方式arr3[索引] 结果&quot;hello world&quot;; 对象object1234567891011121314151617181920212223//由花括分隔 对象的属性以键和值的方式来定义{key:value} {name:'amy'}var person = new Object(); // 定义一个人物对象person.name = 'amy'; // 人物对象中添加了姓名属性 'amy'相当于是属性的值person.age = 18;console.log(person); // {name: &quot;amy&quot;, age: 18}//字面量的方式var person2 ={ name:'john', age:20, height:'175cm', weight:'65kg'};//获取对象属性值（两种方式）person2.name; //'john';person2['age']; //20//函数 function 函数是包裹在花括号中的代码块 使用关键词 functionfunction test(){ console.log(c);}test(); //调用的方式 结果&quot;hello world&quot;;","link":"/2023/03/23/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"数组常用属性和方法","text":"最近因为基础卡住了，补课~ 创建数组 new关键字方式12//使用 JavaScript 关键词 newvar color= new Array(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;); 字面量方式12//使用数组文本创建var color2 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; 在数组中添加值与获取值123456789//数组中添加值color2[3] = 'abc';color2[4] = 'xyz';//获取color2[3] ;//'abc';//获取数组最后一个元素color2[color2.length-1];//获取数组长度color2.length; //5 数组中的方法数组转字符串 如果转成【逗号】号拼接，这个最简单 123//toString() 把数组转换为数组值（以逗号分隔）的字符串。var arr1 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr1.toString(); //&quot;red,blue,green&quot; 如果想用其他符号拼接，用这个 1234//join() 方法也可将所有数组元素结合为一个字符串，可以自定义分隔符var arr2 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];console.log(arr2.join(&quot;:&quot;)) //red:blue:greenconsole.log(arr2.join(&quot; &quot;)) //red blue green 增删改数组元素 添加新元素 在开头添加123//unshift() 方法（在开头）向数组添加新元素 var arr3 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr3.unshift(&quot;abc&quot;);//[&quot;abc&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;] 在结尾添加12//push() 方法（在数组结尾处）向数组添加一个新的元素arr3.push(&quot;xyz&quot;); //[&quot;abc&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;,&quot;xyz&quot;] 删除元素 从后面删123//pop() 方法从数组中删除最后一个元素 pop()返回的是被弹出的值var arr4 = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr4.pop(); //&quot;green&quot; arr4 ======[&quot;red&quot;, &quot;blue&quot;] 从开头删12//shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引，返回的是被弹出的值arr4.shift();//&quot;red&quot; 修改元素1234567891011//splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素则返回的是含有被删除的元素的数组var arr5 = [5,6,7,8];// arr5.splice(位置,个数,添加的新元素)arr5.splice(1,1); //删除了6 arr5 的结果是[5,7,8]arr5.splice(1,0,9);//arr5 的结果是[5, 9, 6, 7, 8]arr5.splice(1,2,3);//arr5 的结果是 [5, 3, 8]//slice()返回一个新的数组，包含从 start 到 end （不包括该元素）的arrayObject 中的元素var arr6 = [5,6,7,8];arr6.slice(1,3) //[6, 7]//arr6 仍然还是[5,6,7,8]; 返回的是选定的元素，该方法不会修改原数组 合并数组12345//concat() 方法用于连接两个或多个数组 该方法不会改变原有的数组var arr7 =[1,2,3];var arr8 = [4,5,6];var arr9 = arr7.concat(arr8);//arr9 [1, 2, 3, 4, 5, 6] 排序123456789//sort()排序var arr10 =[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];arr10.sort(); // [&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;]var arr11 = [1,10,5,12,4,9,22];arr11.sort();// [1, 10, 12, 22, 4, 5, 9]//reverse() 方法用于颠倒数组中元素的顺序 会改变原数组arr11.reverse();// [22, 9, 4, 12, 5, 10, 1] 遍历数组for循环1234567891011121314//for循环遍历var arr12 =[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];var str = &quot;&quot;;for(var i=0;i&lt;arr12.length;i++){ str += &quot;&lt;p&gt;&quot;+arr12[i]+&quot;&lt;/p&gt;&quot;};document.getElementById(&quot;test&quot;).innerHTML= str;//forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。var arr13 =[1,2,3];var a14=[];arr13.forEach(function(item,index){ //item=1 2 3 a14.push(item+1);});console.log(a14); 筛选数组12345678910111213141516171819//filter()对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的组var arr15 = [2,3,5,6,7,18,9];var a15 = arr15.filter(function(item,index){ return item &gt;5; //满足的条件 大于5的结果[6, 7, 18, 9]});类似于&amp;&amp;//every()对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true//每一项都满足条件时返回true,只要有一个不满足返回falsevar a16 = arr15.every(function(item,index){ //return item &gt;5; //必须要求每一个数字都&gt;5才会返回true 否则 false return item&gt;1; //true});类似于||//some()只要有一个满足返回true,都不满足返回falsevar a17 = arr15.some(function(item,index){ //return item &gt;5; //只要有一个满 足了条件，返回true return item==0; //false 都不满足 返回false});","link":"/2022/05/29/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"},{"title":"最近的一点感悟","text":"最近工作很累，至于为什么累呢，我想到几个原因 心态 把心态拿到第一点来说，是因为它真的太重要了，好的情绪可以让你事半功倍，做事情都十分有效率，每个人都会遇到困难与挑战，就看你怎么去面对它，用乐观积极的心态去看待问题，可能暂时解决不了问题，但是会让心情放松，在一定程度上是好的，在这种心态下解决问题也会顺利，如果是很丧的，你周围的气压都是不一样的，自己的心情都是郁闷的，自然做起事来，只要有一点没有做好，就会给自己施压，消极的情绪就放大了，事情也变得糟糕难以解决了，试想你自己都厌恶自己，又有谁愿意与你一起共事呢，自爱才能他爱，所以要训练自己调节心态的能力。 这个项目才中点，我的情绪已经崩了两次了，实在是不应该，我很欣赏我对面的两位前端兄弟，记得有一次他们打开禅道，在打赌说谁bug多一些，bug多的那个人请喝饮料，打开一看，一个人120多个bug，另一个人70多个，本来不太热的办公室，我看到他们俩开始用本子扇起风来，那动作那么的一致（因为两个人都是胖胖的，又一起扇风，难兄难弟的感觉）看得我觉得有趣，于是我问，你们热吗，怎么还扇起来”扇子“了，我对面那个兄弟回答道：你看到这么多bug你不上火吗，我：哈哈哈哈哈。面对困难的不止我一个人，用调侃的方式去看待这些问题何尝不是一件好事呢，总归，不管用什么方式，问题一定是可以解决的，技术层面达不到那就寻求人为层面的方式，这需求实现不了~哈哈。 交流 有一段时间我认为交流毫无用处，写代码就写呗，好好思考技术问题，总是说、交流写的完么？交流那么多干什么？甚至不喜欢的人就不想去交流，除非必须要我去交流的事情我才会去交流，其他的时候就让我得测试代劳去沟通，可能因为关系还不错，我的测试大部分时候已经默认了这种行为。我得一位同事是从别的项目组来的，他因为不熟悉这个项目组的成员，慢慢的也变得和我一样，但是他说起来他之前的项目组，项目经理会把项目成员叫一起开会沟通，其实也和我们差不多，我们也会在项目开始的时候开会沟通，至于在项目过程中是如何操作的，那就不太清楚了，可能以后还会再和他交流相关的话题。这样发生的问题还是有一些的，自己思考难免陷入僵局，或者走进死胡同，而且还有和测试一起合谋漏掉需求的时候，最后被项目经理问起来也是很尴尬的。 让我走出交流无用认知，还是发生了一些事情的，比如遇到了问题自己想了很久也没有想明白，和同事讲了一下，可能好的解决办法并不是用更复杂的技术问题去解决他，换一种思考方式就好解决了，比如同事遇到了问题，向我寻求帮助，我这个局外人很容易看出来问题出在需求，让同事去沟通一下，问题也很好解决了，比如你做过一个需求，当然也是花时间研究过的，同事没有做过这种需求正在挠头，你的几句点拨就让他豁然开朗了，同事就可以按时下班了😏而且和有趣的人交流也可以放松心情，抚慰心灵，下一次你遇到困难的时候不妨和身边的人聊聊天，休息一下，就这一小会儿并不会耽误什么时间，可能正因为这样小小的放松休憩，接下来的工作就会迎刃而解了。 以上的心态和交流的问题如果解决了，其实可以节省出来大量的时间，这次项目我反而是因为这两者浪费了很多时间，还导致了项目延期🤭 难点 拿到我不熟悉的项目确实让我有一些压力，商城应该算to c类型的项目吧，总体来说绘制页面并不是很难，倒是组件和数据结合的时候，我懵了，因为在绘制组件的时候，我还是没有看接口文档的，具体数据结构是什么，在绘制页面的过程中我认为只要能按我写的数据渲染到页面上，到时候调接口我怎么也是可以把他拼成我现在写的这样的是吧，实践过程中有些是可以这样的，当然还是在心态好的时候更容易写出来，心态不好的时候居多，还有一些可能是对需求的理解不是很深入，不想交流，封闭自己，上面也说了，面临的事情不言而喻了。 页面绘制中，像带缩略图的swiper、列头带下拉框的table、table树、富文本、照片墙、标签组可单选复选、页面结构拆的要多细、组件封装的程度、多级路由出口在哪里、权限配置等等，这才只做了一半，很多问题都显现出来了，要思考的东西很多，之后要思考的东西也很多，想要做完项目好好的来一个总结的，在过程中先把稀碎的点记录下来。 接口联调中，如何熟练运用接口的组合，可能后端提供的方式并不是最适合前端的，怎样合理的运用接口，这是其中一个问题遇到的状况，还有的时候是缺乏沟通错误的运用了接口，造成一些逻辑还要重写，树形数据结构递归，树的子节点拼接，遍历嵌套数据，键与值结构的花样变换，对UI组件的熟悉程度，对vue原理的熟悉程度，对webpack的熟悉程度，对路由守卫的熟悉程度等等技术问题也需要去思考。 写在最后 从21年6、7月进入项目组，前期运维工作居多，那个时候也没有和项目组的成员坐到一起，一直都是远程交流的，刚进来有一点不熟悉，但是也很快克服了那个阶段，后面又接了一些项目，比之前有一定难度，但是项目结构大致差不多，有难点却不那么集中，有思考分析的时间，所以倒也没有那么难，再到这个项目前后台两端，还是我第一次接触，对我技术成长有很大的帮助，短时间内要集中解决众多难点，还是有挑战。 虽然项目过半，我没有按期完成，但是通过这次的总结，我明白了应该怎么去做好后面的工作，而且在工作中每一个小小的进步都会让我发自内心的开心与肯定自己，正如墨菲定律中的不值得定律说的那样：“一个人如果在做一件自认为不值得做的事情，即使成功，也不觉得有多大的成就感；如果在做自认为值得做的事情，则会认为每一个进展都很有意义。”朋友圈中有的朋友会吐槽工作、领导多么的sb，有的朋友会发自内心热爱和表达出对工作的热情与喜爱，我想我应该是后者吧，也许有坎坷和苦闷，排除之后留下的更多是开心，我也不悔工作这三年的选择。 在项目中也交到了朋友（最近也零零散散的在看和交友有关的视频和书籍），一位忠实的良师益友比任何财富都重要，感谢协助我搭建博客的朋友，支持鼓励督促我变得更好的朋友🥰 我更应该好好培植与爱护我的“果树”。 想把这个项目作为我在这里三年的最后总结，抱着好好道别的心态，多么不想搞砸的，也可能是给自己的压力过于大了，越想做好的事情越紧张，反而并没有想象中那么好了。过去已然过去了，一万年又太久，只争朝夕吧~","link":"/2022/06/02/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/"},{"title":"深拷贝与浅拷贝","text":"90%公司都会问的JS进阶课程 深浅拷贝深拷贝：把你电脑的安装文件给我一份，你的文件改变不会对我有影响 浅拷贝：复制一份快捷方式，快捷方式放在任何地方都是指向的同一个对象 基本类型与引用类型？基本类型是深拷贝的，存在栈内存引用类型放在堆内存中，栈内存只是存放了引用地址 案例 基本类型——深拷贝 123456var a1 = 1, a2= a1;console.log(a1) //1console.log(a2) //1a2 = 2; //修改 a2console.log(a1) //1console.log(a2) //2 案例 引用类型——浅拷贝 123456var o1 = {x: 1, y: 2}, o2 = o1;console.log(o1) //{x: 1, y: 2}console.log(o2) //{x: 1, y: 2}o2.x = 2; //修改o2.xconsole.log(o1) //{x: 2, y: 2}console.log(o2) //{x: 2, y: 2} 什么是堆？什么是栈？计算器语言有一个处理的过程，写的代码会进行解释或编译执行，这个过程是在内存中，内存的使用和分配，涉及到堆和栈任何语言都有堆和栈 ，堆和栈都存放在内存中 栈：javascript的基本类型就5种:Undefined、Null、Boolean、Number和String，它们都是直接按值存储在栈中，每种类型的数据占用的内存空间的大小是确定的栈由系统自动分配, 例如，声明在函数中一个局部变量var a; 系统自动在栈中为a开辟空间只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出 堆：javascript中其他类型的数据被称为引用类型的数据 : 如对象(Object)、数组(Array)、函数(Function)…，它们是通过拷贝和new出来的，这样的数据存储于堆中其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。 不懂深浅拷贝的危害90%企业问深浅拷贝代码不规范新人不懂，写代码帮倒忙改变全局会有很大影响，需要私有修改 引用类型如何实现深拷贝? 数组用slice和concat方法可以深拷贝 1234var arr =[1,2,3]var arr2 = arrarr2.push(5)console.log(arr)//[1,2,3,5] 案例——slice 1234var arr =[1,2,3]var arr2 = arr.slice(0)arr2.push(5)console.log(arr)//[1,2,3] 案例——concat 1234var arr =[1,2,3]var arr2 = arr.concat()arr2.push(5)console.log(arr)//[1,2,3] 注意：以上只针对一维数组！！ 对象案例——创建一个新对象 123456789101112var obj={ name:'diane', age:18}var obj2 = new Object()obj2.name = obj.nameobj2.age = obj.ageobj.name = 'jack'console.log(obj) // {name: 'jack', age: 18}console.log(obj2) // {name: 'diane', age: 18} 注意：…这种方式也是浅拷贝不是深拷贝！！ 案例——Object.assign()实现深拷贝 123456var obj1 = {a:1,b:2}var obj2 = {b:10,c:20}Object.assign(obj1,obj2)console.log(obj1) // {a:1,b:10,c:20}Object.assign()作用是对属性进行重新分配的，用来把两个对象合并到一块，后面的属性值覆盖前面的，合并到前一个对象中 1234567891011121314var obj1 = {a:1,b:2,sub:{c:3}}function f(o2){ var o = {} Object.assign(o.o2) return o}var a =f(obj1)obj1.a =99a.sub.c = 'aaaaa'console.log(obj1) // {a:99,b:2,sub:{c:'aaaaa'}}console.log(a) // {a:1,b:2,sub:{c:'aaaaa'}}这是典型的浅拷贝，一级是深拷贝，嵌套在里面的是浅拷贝判断深浅拷贝就要看对象中的嵌套对象、嵌套函数拷贝后是否保持原样不丢失 序列化数据交互、数据传输 对象是不行的 bejson.com 格式化校验工具 12345678910JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串var obj = {name:'a',age:20};console.log(typeof JSON.stringify(obj)) JSON.parse() 方法用于将一个 JSON 字符串转换为对象var obj = {name:'a',age:20};var str = JSON.stringify(obj);console.log(typeof JSON.parse(str)) 用序列化实现深拷贝1var new_obj = JSON.parse(JSON.stringify(obj)) 案例——序列化深拷贝 123456789101112var obj={ name:'diane', age:18, o2:{ id:1 }}var obj2 = JSON.parse(JSON.stringify(obj))obj.o2.id = 3console.log(obj) //{age: 18,name: &quot;diane&quot;,o2: {id: 3}}console.log(obj2)//{age: 18,name: &quot;diane&quot;,o2: {id: 1}} 案例——缺点 123456789JSON.parse(JSON.stringify(obj))深拷贝的坑利用JSON.stringify 将js对象序列化 （JSON字符串），再使用JSON.parse来反序列化还原js对象注意以下几点：1.如果obj里面存在时间对象，JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。2.如果obj里有RegExp、Error对象，则序列化的结果格只得到空对象。3.如果obj里有函数，undefined，则序列化的结果会把函数，undefined丟失。4.如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。5.JSON.stringify()只能序列化对象的可枚举的自有属性，如果obj中的对象是由构造函数生成約，则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丟弃对象的constructor。6.如果对象中存在循环引用的情况也无法正确实现深拷贝。 深拷贝终极方案深拷贝的封装写法此方案用到了递归了解一下什么是递归？程序调用自身的编程技巧称为递归，在运行的过程中调用自己 1234567891011121314151617181920212223242526//封装一个方法 deep来实现对象的深拷贝var Animal={ name: &quot;duobi&quot;, skin: [&quot;red&quot;, &quot;green&quot;], child: { xxx: &quot;xxx&quot; }, say: function(){ console.log(&quot;I am &quot;, this.name, &quot; skin:&quot;, this.skin) }}function deep(dest, obj){ var o = dest; for (var key in obj) { // typeof不管是数组还是对象返回都是object if (typeof obj[key] === 'object'){ // constructor用来判断类型是数组还是对象 o[key] = (obj[key].constructor===Array)?[]:{}; deep(o[key], obj[key]); } else { o[key] = obj[key] } } return o;};var x = deep({},Animal); // 调用 总结：如果面试官问你深浅拷贝，这样吊打他1231. 告诉他底层原理，数据是堆内存、栈内存存储的2. 用以上存储方式的数据数据结构：基本数据结构和引用数据结构3. 深浅拷贝的含义","link":"/2022/09/08/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"title":"预解析","text":"详见下文 预解析 变态机制 走后门、关系户有个性化人情味儿在里面 ES5的特色 预解析会解析什么？ var、function 案例——var 1234567console.log(a)var a = 10解析过程var aconsole.log(a) // undefineda = 10 代码执行过程、解析过程 1、提前解析关键字var、function2、提前赋值情况1：对var是仅提前定义没有赋值情况2：对function整体变量提升、并且赋值3、预解析结束后，浏览器再逐行解读代码 案例——function 1234console.log(fn)function fn (){ console.log('123')} 案例 123456789101112131415console.log(b);var b = 100;function b(){ console.log(999)};//解析过程 //预解析var b;function b(){ console.log(999)};//逐行解析console.log(b); //[Function: b]b = 100; 解析原则预解析过程中，当变量和函数同名时：只留下函数的值，不管谁前谁后，所以函数优先级更高； 案例——测试变量和函数的优先级 1234567891011121314console.log(b);function b(){ console.log(999)};var b = 100;//解析过程 //预解析function b(){ console.log(999)};var b;//逐行解析console.log(b); //[Function: b]b = 100; 123456789101112131415161718192021222324252627//扩展练习一console.log(a,b,c,d,e);var a = 10;var b;c = 100;function d(){ console.log('d')};var e = function(){ console.log('e')};//解析过程 //预解析var a;var b;function d(){ console.log('d')};var e;//逐行解析console.log(a,b,c,d,e); //a = undefined; b = undefined; c-报错; d=function(){}; e = undefined; a = 10;c = 100;e = function(){ console.log('e')}; 12345678910111213141516171819202122//扩展练习二console.log(a);var a = 1;function a(){console.log(2)};console.log(a);var a = 3;console.log(a);function a(){console.log(4)};console.log(a);//解析过程 //预解析var a;function a(){console.log(2)};function a(){console.log(4)};//逐行解析console.log(a); //function a(){console.log(4)};a = 1;console.log(a); //1a = 3;console.log(a); //3console.log(a); //3 预解析经典面试题 12345678910111213141516171819202122232425function fun ( n ) { console.log( n ); var n = 456; console.log( n );}var n = 123;fun( n );答：123 456 //解析过程 //预解析 var n; function fun(){}; n = 123 //全局变量 fun(n) ////当执行fun(n)，会执行函数体里的内容，此时fun函数会形成一个新的私有作用域 //fun()内部解析过程 //如果有形参，先给形参赋值 var n = 123; //进行私有作用域中的预解析； var n; //私有作用域中的代码从上到下执行 console.log( n ); //123 n = 456; console.log( n ); //456","link":"/2023/03/23/%E9%A2%84%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"js","slug":"js","link":"/tags/js/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"async","slug":"async","link":"/tags/async/"},{"name":"await","slug":"await","link":"/tags/await/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"感悟","slug":"感悟","link":"/tags/%E6%84%9F%E6%82%9F/"},{"name":"思考","slug":"思考","link":"/tags/%E6%80%9D%E8%80%83/"},{"name":"深拷贝和浅拷贝","slug":"深拷贝和浅拷贝","link":"/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"日常记录","slug":"日常记录","link":"/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}]}